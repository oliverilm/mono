"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LlmApplicationOfValidateTransformer = void 0;
const typescript_1 = __importDefault(require("typescript"));
const ExpressionFactory_1 = require("../../../factories/ExpressionFactory");
const LiteralFactory_1 = require("../../../factories/LiteralFactory");
const MetadataCollection_1 = require("../../../factories/MetadataCollection");
const MetadataFactory_1 = require("../../../factories/MetadataFactory");
const StatementFactory_1 = require("../../../factories/StatementFactory");
const LlmApplicationOfValidateProgrammer_1 = require("../../../programmers/llm/LlmApplicationOfValidateProgrammer");
const LlmModelPredicator_1 = require("../../../programmers/llm/LlmModelPredicator");
const TransformerError_1 = require("../../TransformerError");
var LlmApplicationOfValidateTransformer;
(function (LlmApplicationOfValidateTransformer) {
    LlmApplicationOfValidateTransformer.transform = (props) => {
        var _a, _b, _c;
        // GET GENERIC ARGUMENT
        if (!((_a = props.expression.typeArguments) === null || _a === void 0 ? void 0 : _a.length))
            throw new TransformerError_1.TransformerError({
                code: "typia.llm.schema",
                message: "no generic argument.",
            });
        const top = props.expression.typeArguments[0];
        if (typescript_1.default.isTypeNode(top) === false)
            return props.expression;
        // GET TYPE
        const model = LlmModelPredicator_1.LlmModelPredicator.getModel({
            checker: props.context.checker,
            method: "application",
            node: props.expression.typeArguments[1],
        });
        const type = props.context.checker.getTypeFromTypeNode(top);
        const collection = new MetadataCollection_1.MetadataCollection({
            replace: MetadataCollection_1.MetadataCollection.replace,
        });
        const result = MetadataFactory_1.MetadataFactory.analyze({
            checker: props.context.checker,
            transformer: props.context.transformer,
            options: {
                escape: true,
                constant: true,
                absorb: false,
                functional: true,
                validate: LlmApplicationOfValidateProgrammer_1.LlmApplicationOfValidateProgrammer.validate(model),
            },
            collection,
            type,
        });
        if (result.success === false)
            throw TransformerError_1.TransformerError.from({
                code: "typia.llm.application",
                errors: result.errors,
            });
        // GENERATE LLM APPLICATION
        const schema = LlmApplicationOfValidateProgrammer_1.LlmApplicationOfValidateProgrammer.write({
            model,
            context: props.context,
            modulo: props.modulo,
            metadata: result.data,
            config: LlmModelPredicator_1.LlmModelPredicator.getConfig({
                context: props.context,
                method: "application",
                model,
                node: props.expression.typeArguments[2],
            }),
        });
        const literal = typescript_1.default.factory.createAsExpression(LiteralFactory_1.LiteralFactory.write(schema), props.context.importer.type({
            file: "typia",
            name: "ILlmApplicationOfValidate",
            arguments: [
                typescript_1.default.factory.createLiteralTypeNode(typescript_1.default.factory.createStringLiteral(model)),
            ],
        }));
        if (!((_b = props.expression.arguments) === null || _b === void 0 ? void 0 : _b[0]))
            return literal;
        return ExpressionFactory_1.ExpressionFactory.selfCall(typescript_1.default.factory.createBlock([
            StatementFactory_1.StatementFactory.constant({
                name: "app",
                value: literal,
            }),
            typescript_1.default.factory.createExpressionStatement(typescript_1.default.factory.createCallExpression(props.context.importer.internal("llmApplicationFinalize"), undefined, [
                typescript_1.default.factory.createIdentifier("app"),
                ...(((_c = props.expression.arguments) === null || _c === void 0 ? void 0 : _c[0])
                    ? [props.expression.arguments[0]]
                    : []),
            ])),
            typescript_1.default.factory.createReturnStatement(typescript_1.default.factory.createIdentifier("app")),
        ], true));
    };
})(LlmApplicationOfValidateTransformer || (exports.LlmApplicationOfValidateTransformer = LlmApplicationOfValidateTransformer = {}));
//# sourceMappingURL=LlmApplicationOfValidateTransformer.js.map