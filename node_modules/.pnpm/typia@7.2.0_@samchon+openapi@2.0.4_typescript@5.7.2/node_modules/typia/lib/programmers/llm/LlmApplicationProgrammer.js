"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LlmApplicationProgrammer = void 0;
const LlmSchemaComposer_1 = require("@samchon/openapi/lib/composers/LlmSchemaComposer");
const JsonApplicationProgrammer_1 = require("../json/JsonApplicationProgrammer");
const LlmSchemaProgrammer_1 = require("./LlmSchemaProgrammer");
var LlmApplicationProgrammer;
(function (LlmApplicationProgrammer) {
    LlmApplicationProgrammer.validate = (model) => {
        let top;
        return (metadata, explore) => {
            var _a, _b;
            top !== null && top !== void 0 ? top : (top = metadata);
            if (explore.top === false)
                if (explore.object === ((_a = top === null || top === void 0 ? void 0 : top.objects[0]) === null || _a === void 0 ? void 0 : _a.type) &&
                    typeof explore.property === "string" &&
                    metadata.size() === 1 &&
                    metadata.nullable === false &&
                    metadata.isRequired() === true &&
                    metadata.functions.length === 1)
                    return validateFunction(explore.property, metadata.functions[0]);
                else
                    return LlmSchemaProgrammer_1.LlmSchemaProgrammer.validate(model)(metadata);
            const output = [];
            const valid = metadata.size() === 1 &&
                metadata.objects.length === 1 &&
                metadata.isRequired() === true &&
                metadata.nullable === false;
            if (valid === false)
                output.push("LLM application's generic arugment must be a class/interface type.");
            const object = (_b = metadata.objects[0]) === null || _b === void 0 ? void 0 : _b.type;
            if (object !== undefined) {
                if (object.properties.some((p) => p.key.isSoleLiteral() === false))
                    output.push("LLM application does not allow dynamic keys on class/interface type.");
                let least = false;
                for (const p of object.properties) {
                    const value = p.value;
                    if (value.functions.length) {
                        least || (least = true);
                        if (valid === false) {
                            if (value.functions.length !== 1 || value.size() !== 1)
                                output.push("LLM application's function type does not allow union type.");
                            if (value.isRequired() === false)
                                output.push("LLM application's function type must be required.");
                            if (value.nullable === true)
                                output.push("LLM application's function type must not be nullable.");
                        }
                    }
                }
                if (least === false)
                    output.push("LLM application's target type must have at least a function type.");
            }
            return output;
        };
    };
    const validateFunction = (name, func) => {
        const output = [];
        const prefix = `LLM application's function (${JSON.stringify(name)})`;
        if (func.output.size() && func.output.isRequired() === false)
            output.push(`${prefix}'s return type must not be union type with undefined.`);
        if (func.parameters.length !== 1)
            output.push(`${prefix} must have a single parameter.`);
        if (func.parameters.length !== 0) {
            const type = func.parameters[0].type;
            if (type.size() !== 1 || type.objects.length !== 1)
                output.push(`${prefix}'s parameter must be an object type.`);
            else {
                if (type.objects[0].type.properties.some((p) => p.key.isSoleLiteral() === false))
                    output.push(`${prefix}'s parameter must not have dynamic keys.`);
                if (type.isRequired() === false)
                    output.push(`${prefix}'s parameter must not be union type with undefined.`);
                if (type.nullable === true)
                    output.push(`${prefix}'s parameter must not be nullable.`);
            }
        }
        return output;
    };
    LlmApplicationProgrammer.write = (props) => {
        const errors = LlmApplicationProgrammer.validate(props.model)(props.metadata, {
            top: true,
            object: null,
            property: null,
            parameter: null,
            nested: null,
            aliased: false,
            escaped: false,
            output: false,
        });
        if (errors.length)
            throw new Error("Failed to write LLM application: " + errors.join("\n"));
        const errorMessages = [];
        const application = JsonApplicationProgrammer_1.JsonApplicationProgrammer.write({
            version: "3.1",
            metadata: props.metadata,
        });
        const functions = application.functions.map((func) => writeFunction({
            model: props.model,
            components: application.components,
            function: func,
            errors: errorMessages,
        }));
        if (functions.some((func) => func === null))
            throw new Error("Failed to write LLM application:\n\n" +
                errorMessages.map((str) => `  - ${str}`).join("\n"));
        return {
            model: props.model,
            options: Object.assign(Object.assign(Object.assign({}, LlmSchemaComposer_1.LlmSchemaComposer.defaultConfig(props.model)), props.config), { separate: null }),
            functions: functions,
        };
    };
    const writeFunction = (props) => {
        var _a, _b, _c, _d;
        const parameters = writeParameters(Object.assign(Object.assign({}, props), { accessor: `$input.${props.function.name}.parameters` }));
        if (parameters === null)
            return null;
        const output = writeOutput({
            model: props.model,
            parameters,
            components: props.components,
            schema: (_b = (_a = props.function.output) === null || _a === void 0 ? void 0 : _a.schema) !== null && _b !== void 0 ? _b : null,
            errors: props.errors,
            accessor: `$input.${props.function.name}.output`,
        });
        if (output === null)
            return null;
        else if (output &&
            output.description === undefined &&
            !!((_d = (_c = props.function.output) === null || _c === void 0 ? void 0 : _c.description) === null || _d === void 0 ? void 0 : _d.length))
            output.description = props.function.output.description;
        return {
            name: props.function.name,
            parameters,
            output: (output !== null && output !== void 0 ? output : undefined),
            description: (() => {
                var _a, _b;
                if (!((_a = props.function.summary) === null || _a === void 0 ? void 0 : _a.length) ||
                    !((_b = props.function.description) === null || _b === void 0 ? void 0 : _b.length))
                    return props.function.summary || props.function.description;
                const summary = props.function.summary.endsWith(".")
                    ? props.function.summary.slice(0, -1)
                    : props.function.summary;
                return props.function.description.startsWith(summary)
                    ? props.function.description
                    : summary + ".\n\n" + props.function.description;
            })(),
            deprecated: props.function.deprecated,
            tags: props.function.tags,
            strict: true,
        };
    };
    const writeParameters = (props) => {
        var _a;
        const schema = (_a = props.function.parameters[0]) === null || _a === void 0 ? void 0 : _a.schema;
        if (!schema)
            return null;
        const result = LlmSchemaComposer_1.LlmSchemaComposer.parameters(props.model)({
            config: LlmSchemaComposer_1.LlmSchemaComposer.defaultConfig(props.model),
            components: props.components,
            schema: schema,
            accessor: props.accessor,
        });
        if (result.success === false) {
            props.errors.push(...result.error.reasons.map((r) => `  - ${r.accessor}: ${r.message}`));
            return null;
        }
        return result.value;
    };
    const writeOutput = (props) => {
        if (props.schema === null)
            return undefined;
        const result = LlmSchemaComposer_1.LlmSchemaComposer.schema(props.model)({
            config: LlmSchemaComposer_1.LlmSchemaComposer.defaultConfig(props.model),
            components: props.components,
            schema: props.schema,
            $defs: props.parameters.$defs,
            accessor: props.accessor,
        });
        if (result.success === false) {
            props.errors.push(...result.error.reasons.map((r) => `  - ${r.accessor}: ${r.message}`));
            return null;
        }
        return result.value;
    };
})(LlmApplicationProgrammer || (exports.LlmApplicationProgrammer = LlmApplicationProgrammer = {}));
//# sourceMappingURL=LlmApplicationProgrammer.js.map