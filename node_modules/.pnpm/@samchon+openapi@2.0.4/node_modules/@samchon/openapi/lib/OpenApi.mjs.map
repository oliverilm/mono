{"version":3,"file":"OpenApi.mjs","sources":["../src/OpenApi.ts"],"sourcesContent":["import { OpenApiV3 } from \"./OpenApiV3\";\nimport { OpenApiV3_1 } from \"./OpenApiV3_1\";\nimport { SwaggerV2 } from \"./SwaggerV2\";\nimport { OpenApiV3Downgrader } from \"./converters/OpenApiV3Downgrader\";\nimport { OpenApiV3Upgrader } from \"./converters/OpenApiV3Upgrader\";\nimport { OpenApiV3_1Emender } from \"./converters/OpenApiV3_1Emender\";\nimport { SwaggerV2Downgrader } from \"./converters/SwaggerV2Downgrader\";\nimport { SwaggerV2Upgrader } from \"./converters/SwaggerV2Upgrader\";\n\n/**\n * Emended OpenAPI v3.1 definition used by `typia` and `nestia`.\n *\n * `OpenApi` is a namespace containing functions and interfaces for emended\n * OpenAPI v3.1 specification. The keyword \"emended\" means that `OpenApi` is\n * not a direct OpenAPI v3.1 specification ({@link OpenApiV3_1}), but a little\n * bit shrinked to remove ambiguous and duplicated expressions of OpenAPI v3.1\n * for the convenience of `typia` and `nestia`.\n *\n * For example, when representing nullable type, OpenAPI v3.1 supports three ways.\n * In that case, `OpenApi` remains only the third way, so that makes `typia` and\n * `nestia` (especially `@nestia/editor`) to be simple and easy to implement.\n *\n * 1. `{ type: [\"string\", \"null\"] }`\n * 2. `{ type: \"string\", nullable: true }`\n * 3. `{ oneOf: [{ type: \"string\" }, { type: \"null\" }] }`\n *\n * Here is the entire list of differences between OpenAPI v3.1 and emended `OpenApi`.\n *\n * - Operation\n *   - Merge {@link OpenApiV3_1.IPath.parameters} to {@link OpenApi.IOperation.parameters}\n *   - Resolve {@link OpenApi.IJsonSchema.IReference references} of {@link OpenApiV3_1.IOperation} members\n *   - Escape references of {@link OpenApiV3_1.IComponent.examples}\n * - JSON Schema\n *   - Decompose mixed type: {@link OpenApiV3_1.IJsonSchema.IMixed}\n *   - Resolve nullable property: {@link OpenApiV3_1.IJsonSchema.__ISignificant.nullable}\n *   - Array type utilizes only single {@link OpenAPI.IJsonSchema.IArray.items}\n *   - Tuple type utilizes only {@link OpenApi.IJsonSchema.ITuple.prefixItems}\n *   - Merge {@link OpenApiV3_1.IJsonSchema.IAllOf} to {@link OpenApi.IJsonSchema.IObject}\n *   - Merge {@link OpenApiV3_1.IJsonSchema.IAnyOf} to {@link OpenApi.IJsonSchema.IOneOf}\n *   - Merge {@link OpenApiV3_1.IJsonSchema.IRecursiveReference} to {@link OpenApi.IJsonSchema.IReference}\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport namespace OpenApi {\n  /**\n   * Method of the operation.\n   */\n  export type Method =\n    | \"get\"\n    | \"post\"\n    | \"put\"\n    | \"delete\"\n    | \"options\"\n    | \"head\"\n    | \"patch\"\n    | \"trace\";\n\n  /**\n   * Convert Swagger or OpenAPI document into emended OpenAPI v3.1 document.\n   *\n   * @param input Swagger or OpenAPI document to convert\n   * @returns Emended OpenAPI v3.1 document\n   */\n  export function convert(\n    input:\n      | SwaggerV2.IDocument\n      | OpenApiV3.IDocument\n      | OpenApiV3_1.IDocument\n      | OpenApi.IDocument,\n  ): IDocument {\n    if (OpenApiV3_1.is(input))\n      return OpenApiV3_1Emender.convert(input) as IDocument;\n    else if (OpenApiV3.is(input))\n      return OpenApiV3Upgrader.convert(input) as IDocument;\n    else if (SwaggerV2.is(input))\n      return SwaggerV2Upgrader.convert(input) as IDocument;\n    throw new TypeError(\"Unrecognized Swagger/OpenAPI version.\");\n  }\n\n  /**\n   * Downgrade to Swagger v2.0 document.\n   *\n   * Downgrade the given document (emeneded OpenAPI v3.1) into Swagger v2.0.\n   *\n   * @param document Emended OpenAPI v3.1 document to downgrade\n   * @param version Version to downgrade\n   * @returns Swagger v2.0 document\n   */\n  export function downgrade(\n    document: IDocument,\n    version: \"2.0\",\n  ): SwaggerV2.IDocument;\n\n  /**\n   * Downgrade to OpenAPI v3.0 document.\n   *\n   * Downgrade the given document (emeneded OpenAPI v3.1) into OpenAPI v3.0.\n   *\n   * @param document Emended OpenAPI v3.1 document to downgrade\n   * @param version Version to downgrade\n   * @returns OpenAPI v3.0 document\n   */\n  export function downgrade(\n    document: IDocument,\n    version: \"3.0\",\n  ): OpenApiV3.IDocument;\n\n  /**\n   * @internal\n   */\n  export function downgrade(\n    document: IDocument,\n    version: string,\n  ): SwaggerV2.IDocument | OpenApiV3.IDocument {\n    if (version === \"2.0\") return SwaggerV2Downgrader.downgrade(document);\n    else if (version === \"3.0\") return OpenApiV3Downgrader.downgrade(document);\n    throw new TypeError(\"Unrecognized Swagger/OpenAPI version.\");\n  }\n\n  /* -----------------------------------------------------------\n    PATH ITEMS\n  ----------------------------------------------------------- */\n  /**\n   * OpenAPI document.\n   *\n   * `OpenApi.IDocument` represents an OpenAPI document of emended OpenAPI v3.1.\n   *\n   * In other words, `OpenApi.IDocument` is a structure of `swagger.json` file of\n   * OpenAPI v3.1 specification, but a little bit shrinked to remove ambiguous and\n   * duplicated expressions of OpenAPI v3.1 for the convenience and clarity.\n   */\n  export interface IDocument {\n    /**\n     * OpenAPI version number.\n     */\n    openapi: `3.1.${number}`;\n\n    /**\n     * List of servers that provide the API.\n     */\n    servers?: IServer[];\n\n    /**\n     * Information about the API.\n     */\n    info?: IDocument.IInfo;\n\n    /**\n     * An object to hold reusable data structures.\n     *\n     * It stores both DTO schemas and security schemes.\n     *\n     * For reference, `nestia` defines every object and alias types as reusable DTO\n     * schemas. The alias type means that defined by `type` keyword in TypeScript.\n     */\n    components: IComponents;\n\n    /**\n     * The available paths and operations for the API.\n     *\n     * The 1st key is the path, and the 2nd key is the HTTP method.\n     */\n    paths?: Record<string, IPath>;\n\n    /**\n     * An object to hold Webhooks.\n     *\n     * Its structure is same with {@link paths}, so that the 1st key is the path,\n     * and the 2nd key is the HTTP method.\n     */\n    webhooks?: Record<string, IPath>;\n\n    /**\n     * A declaration of which security mechanisms can be used across the API.\n     *\n     * When this property be configured, it would be overwritten in every API routes.\n     *\n     * For reference, key means the name of security scheme and value means the `scopes`.\n     * The `scopes` can be used only when target security scheme is `oauth2` type,\n     * especially for {@link ISwaggerSecurityScheme.IOAuth2.IFlow.scopes} property.\n     */\n    security?: Record<string, string[]>[];\n\n    /**\n     * List of tag names with description.\n     *\n     * It is possible to omit this property or skip some tag name even if\n     * the tag name is used in the API routes. In that case, the tag name\n     * would be displayed (in Swagger-UI) without description.\n     */\n    tags?: IDocument.ITag[];\n\n    /**\n     * Flag for indicating this document is emended by `@samchon/openapi`.\n     */\n    \"x-samchon-emended\": true;\n  }\n  export namespace IDocument {\n    /**\n     * Information about the API.\n     */\n    export interface IInfo {\n      /**\n       * The title of the API.\n       */\n      title: string;\n\n      /**\n       * A short summary of the API.\n       */\n      summary?: string;\n\n      /**\n       * A full description of the API.\n       */\n      description?: string;\n\n      /**\n       * A URL to the Terms of Service for the API.\n       */\n      termsOfService?: string;\n\n      /**\n       * The contact information for the exposed API.\n       */\n      contact?: IContact;\n\n      /**\n       * The license information for the exposed API.\n       */\n      license?: ILicense;\n\n      /**\n       * Version of the API.\n       */\n      version: string;\n    }\n\n    /**\n     * OpenAPI tag information.\n     *\n     * It is possible to skip composing this structure, even if some\n     * tag names are regsitered in the API routes ({@link OpenApi.IOperation.tags}).\n     * In that case, the tag name would be displayed in Swagger-UI without\n     * description.\n     *\n     * However, if you want to describe the tag name, you can compose this\n     * structure and describe the tag name in the {@link description} property.\n     */\n    export interface ITag {\n      /**\n       * The name of the tag.\n       */\n      name: string;\n\n      /**\n       * An optional string describing the tag.\n       */\n      description?: string;\n    }\n\n    /**\n     * Contact information for the exposed API.\n     */\n    export interface IContact {\n      /**\n       * The identifying name of the contact person/organization.\n       */\n      name?: string;\n\n      /**\n       * The URL pointing to the contact information.\n       */\n      url?: string;\n\n      /**\n       * The email address of the contact person/organization.\n       *\n       * @format email\n       */\n      email?: string;\n    }\n\n    /**\n     * License information for the exposed API.\n     */\n    export interface ILicense {\n      /**\n       * The license name used for the API.\n       */\n      name: string;\n\n      /**\n       * Identifier for the license used for the API.\n       *\n       * example: MIT\n       */\n      identifier?: string;\n\n      /**\n       * A URL to the license used for the API.\n       */\n      url?: string;\n    }\n  }\n\n  /**\n   * The remote server that provides the API.\n   */\n  export interface IServer {\n    /**\n     * A URL to the target host.\n     */\n    url: string;\n\n    /**\n     * An optional string describing the target server.\n     */\n    description?: string;\n\n    /**\n     * A map between a variable name and its value.\n     *\n     * When the server {@link url} is a type of template, this property\n     * would be utilized to fill the template with actual values.\n     */\n    variables?: Record<string, IServer.IVariable>;\n  }\n  export namespace IServer {\n    /**\n     * A variable for the server URL template.\n     */\n    export interface IVariable {\n      /**\n       * Default value to use for substitution.\n       */\n      default: string;\n\n      /**\n       * List of available values for the variable.\n       */\n      enum?: string[];\n\n      /**\n       * An optional description for the server variable.\n       */\n      description?: string;\n    }\n  }\n\n  /* -----------------------------------------------------------\n    OPERATORS\n  ----------------------------------------------------------- */\n  /**\n   * Path item.\n   *\n   * `OpenApi.IPath` represents a path item of emended OpenAPI v3.1,\n   * collecting multiple method operations in a single path.\n   */\n  export interface IPath extends Partial<Record<Method, IOperation>> {\n    /**\n     * Servers that provide the path operations.\n     */\n    servers?: IServer[];\n\n    /**\n     * Summary of the path.\n     */\n    summary?: string;\n\n    /**\n     * Description of the path.\n     */\n    description?: string;\n  }\n\n  /**\n   * Remote operation info.\n   *\n   * `OpenApi.IOperation` represents an Restful API operation provided by the\n   * remote server.\n   */\n  export interface IOperation {\n    /**\n     * Unique string used to identify the operation.\n     */\n    operationId?: string;\n\n    /**\n     * List of parameters that are applicable for this operation.\n     */\n    parameters?: IOperation.IParameter[];\n\n    /**\n     * The request body applicable for this operation.\n     */\n    requestBody?: IOperation.IRequestBody;\n\n    /**\n     * The list of possible responses as they are returned from executing this\n     * operation. Its key is the HTTP status code, and the value is the metadata of\n     * the response in the HTTP status code.\n     */\n    responses?: Record<string, IOperation.IResponse>;\n\n    /**\n     * A list of servers providing this API operation.\n     */\n    servers?: IServer[];\n\n    /**\n     * A short summary of what the operation does.\n     */\n    summary?: string;\n\n    /**\n     * A verbose explanation of the operation behavior.\n     */\n    description?: string;\n\n    /**\n     * List of securities and their scopes that are required for execution.\n     *\n     * When this property be configured, the Restful API operation requires\n     * the matched security value for exection. Its key means security key\n     * matched with {@link OpenApi.IDocument.security}.\n     *\n     * The value means scopes required for the security key when the security\n     * type is {@link OpenApi.ISecurityScheme.IOAuth2}. Otherwise the target\n     * security type is not {@link OpenApi.ISecurityScheme.IOAuth2}, the value\n     * would be empty array.\n     */\n    security?: Record<string, string[]>[];\n\n    /**\n     * Tags for API documentation control.\n     */\n    tags?: string[];\n\n    /**\n     * Flag for indicating this operation is deprecated.\n     */\n    deprecated?: boolean;\n\n    /**\n     * Flag for indicating this operation is human-only.\n     *\n     * If this property value is `true`, {@link HttpLlm.application}\n     * function will not convert this operation schema into the LLM function\n     * calling schema that is represented by the {@link IHttpLlmFunction}\n     * interface.\n     */\n    \"x-samchon-human\"?: boolean;\n  }\n  export namespace IOperation {\n    /**\n     * Parameter of the operation.\n     */\n    export interface IParameter {\n      /**\n       * Representative name of the parameter.\n       *\n       * In the most case, the `name` is equivalent to parameter variable name.\n       * Therefore, the `name` must be filled with the significant variable name\n       * of the parameter.\n       *\n       * By the way, only when the {@link in} property is `path`, the `name`\n       * can be omitted. In that case, the `name` is automatically deduced from\n       * the URL path's positional template argument analyzing.\n       */\n      name?: string;\n\n      /**\n       * Location of the parameter.\n       *\n       * The `in` property is a string that determines the location of the parameter.\n       *\n       * - `path`: parameter is part of the path of the URL.\n       * - `query`: parameter is part of the query string.\n       * - `header`: parameter is part of the header.\n       * - `cookie`: parameter is part of the cookie.\n       */\n      in: \"path\" | \"query\" | \"header\" | \"cookie\";\n\n      /**\n       * Type info of the parameter.\n       */\n      schema: IJsonSchema;\n\n      /**\n       * Whether the parameter is required for execution or not.\n       *\n       * If the parameter is required, the value must be filled. Otherwise,\n       * it is possible to skip the parameter when executing the APi operation.\n       *\n       * For reference, the `required` property must be always `true` when the\n       * {@link in} property is `path`. Otherwise, the `required` property can\n       * be anything of them; `true`, `false` and `undefined`.\n       */\n      required?: boolean;\n\n      /**\n       * Short title of the parameter.\n       */\n      title?: string;\n\n      /**\n       * Verbose explanation of the parameter.\n       */\n      description?: string;\n\n      /**\n       * Example value of the parameter.\n       */\n      example?: any;\n\n      /**\n       * Collection of example values of the parameter with keys.\n       */\n      examples?: Record<string, IExample>;\n    }\n\n    /**\n     * Request body of the operation.\n     */\n    export interface IRequestBody {\n      content?: IContent;\n      description?: string;\n      required?: boolean;\n      \"x-nestia-encrypted\"?: boolean;\n    }\n\n    /**\n     * Response of the operation.\n     */\n    export interface IResponse {\n      headers?: Record<string, IOperation.IParameter>;\n      content?: IContent;\n      description?: string;\n      \"x-nestia-encrypted\"?: boolean;\n    }\n\n    /**\n     * List of content types supported in request/response body.\n     */\n    export interface IContent\n      extends Partial<Record<ContentType, IMediaType>> {}\n\n    /**\n     * Media type of a request/response body.\n     */\n    export interface IMediaType {\n      schema?: IJsonSchema;\n      example?: any;\n      examples?: Record<string, IExample>;\n    }\n\n    /**\n     * List of supported content media types.\n     */\n    export type ContentType =\n      | \"text/plain\"\n      | \"application/json\"\n      | \"application/x-www-form-url-encoded\"\n      | \"multipart/form-data\"\n      | \"*/*\"\n      | (string & {});\n  }\n\n  /**\n   * Example of the operation parameter or response.\n   */\n  export interface IExample {\n    summary?: string;\n    description?: string;\n    value?: any;\n    externalValue?: string;\n  }\n\n  /* -----------------------------------------------------------\n    SCHEMA DEFINITIONS\n  ----------------------------------------------------------- */\n  /**\n   * Reusable components in OpenAPI.\n   *\n   * A storage of reusable components in OpenAPI document.\n   *\n   * In other words, it is a storage of named DTO schemas and security schemes.\n   */\n  export interface IComponents {\n    /**\n     * An object to hold reusable DTO schemas.\n     *\n     * In other words, a collection of named JSON schemas.\n     */\n    schemas?: Record<string, IJsonSchema>;\n\n    /**\n     * An object to hold reusable security schemes.\n     *\n     * In other words, a collection of named security schemes.\n     */\n    securitySchemes?: Record<string, ISecurityScheme>;\n  }\n\n  /**\n   * Type schema info.\n   *\n   * `OpenApi.IJsonSchema` is a type schema info of the OpenAPI.\n   *\n   * `OpenApi.IJsonSchema` basically follows the JSON schema definition of\n   * OpenAPI v3.1, but a little bit shrinked to remove ambiguous and duplicated\n   * expressions of OpenAPI v3.1 for the convenience and clarity.\n   *\n   * - Decompose mixed type: {@link OpenApiV3_1.IJsonSchema.IMixed}\n   * - Resolve nullable property: {@link OpenApiV3_1.IJsonSchema.__ISignificant.nullable}\n   * - Array type utilizes only single {@link OpenAPI.IJsonSchema.IArray.items}\n   * - Tuple type utilizes only {@link OpenApi.IJsonSchema.ITuple.prefixItems}\n   * - Merge {@link OpenApiV3_1.IJsonSchema.IAllOf} to {@link OpenApi.IJsonSchema.IObject}\n   * - Merge {@link OpenApiV3_1.IJsonSchema.IAnyOf} to {@link OpenApi.IJsonSchema.IOneOf}\n   * - Merge {@link OpenApiV3_1.IJsonSchema.IRecursiveReference} to {@link OpenApi.IJsonSchema.IReference}\n   */\n  export type IJsonSchema =\n    | IJsonSchema.IConstant\n    | IJsonSchema.IBoolean\n    | IJsonSchema.IInteger\n    | IJsonSchema.INumber\n    | IJsonSchema.IString\n    | IJsonSchema.IArray\n    | IJsonSchema.ITuple\n    | IJsonSchema.IObject\n    | IJsonSchema.IReference\n    | IJsonSchema.IOneOf\n    | IJsonSchema.INull\n    | IJsonSchema.IUnknown;\n  export namespace IJsonSchema {\n    /**\n     * Constant value type.\n     */\n    export interface IConstant extends __IAttribute {\n      /**\n       * The constant value.\n       */\n      const: boolean | number | string;\n    }\n\n    /**\n     * Boolean type info.\n     */\n    export interface IBoolean extends __ISignificant<\"boolean\"> {\n      /**\n       * The default value.\n       */\n      default?: boolean;\n    }\n\n    /**\n     * Integer type info.\n     */\n    export interface IInteger extends __ISignificant<\"integer\"> {\n      /**\n       * Default value.\n       *\n       * @type int64\n       */\n      default?: number;\n\n      /**\n       * Minimum value restriction.\n       *\n       * @type int64\n       */\n      minimum?: number;\n\n      /**\n       * Maximum value restriction.\n       *\n       * @type int64\n       */\n      maximum?: number;\n\n      /**\n       * Exclusive minimum value restriction.\n       *\n       * For reference, even though your Swagger (or OpenAPI) document has\n       * defined the `exclusiveMinimum` value as `number`, {@link OpenApi}\n       * forcibly converts it to `boolean` type, and assign the numeric value to\n       * the {@link minimum} property.\n       */\n      exclusiveMinimum?: boolean;\n\n      /**\n       * Exclusive maximum value restriction.\n       *\n       * For reference, even though your Swagger (or OpenAPI) document has\n       * defined the `exclusiveMaximum` value as `number`, {@link OpenApi}\n       * forcibly converts it to `boolean` type, and assign the numeric value to\n       * the {@link maximum} property.\n       */\n      exclusiveMaximum?: boolean;\n\n      /**\n       * Multiple of value restriction.\n       *\n       * @type uint64\n       * @exclusiveMinimum 0\n       */\n      multipleOf?: number;\n    }\n\n    /**\n     * Number (double) type info.\n     */\n    export interface INumber extends __ISignificant<\"number\"> {\n      /**\n       * Default value.\n       */\n      default?: number;\n\n      /**\n       * Minimum value restriction.\n       */\n      minimum?: number;\n\n      /**\n       * Maximum value restriction.\n       */\n      maximum?: number;\n\n      /**\n       * Exclusive minimum value restriction.\n       *\n       * For reference, even though your Swagger (or OpenAPI) document has\n       * defined the `exclusiveMinimum` value as `number`, {@link OpenAiComposer}\n       * forcibly converts it to `boolean` type, and assign the numeric value to\n       * the {@link minimum} property.\n       */\n      exclusiveMinimum?: boolean;\n\n      /**\n       * Exclusive maximum value restriction.\n       *\n       * For reference, even though your Swagger (or OpenAPI) document has\n       * defined the `exclusiveMaximum` value as `number`, {@link OpenAiComposer}\n       * forcibly converts it to `boolean` type, and assign the numeric value to\n       * the {@link maximum} property.\n       */\n      exclusiveMaximum?: boolean;\n\n      /**\n       * Multiple of value restriction.\n       *\n       * @exclusiveMinimum 0\n       */\n      multipleOf?: number;\n    }\n\n    /**\n     * String type info.\n     */\n    export interface IString extends __ISignificant<\"string\"> {\n      /**\n       * Default value.\n       */\n      default?: string;\n\n      /**\n       * Format restriction.\n       */\n      format?:\n        | \"binary\"\n        | \"byte\"\n        | \"password\"\n        | \"regex\"\n        | \"uuid\"\n        | \"email\"\n        | \"hostname\"\n        | \"idn-email\"\n        | \"idn-hostname\"\n        | \"iri\"\n        | \"iri-reference\"\n        | \"ipv4\"\n        | \"ipv6\"\n        | \"uri\"\n        | \"uri-reference\"\n        | \"uri-template\"\n        | \"url\"\n        | \"date-time\"\n        | \"date\"\n        | \"time\"\n        | \"duration\"\n        | \"json-pointer\"\n        | \"relative-json-pointer\"\n        | (string & {});\n\n      /**\n       * Pattern restriction.\n       */\n      pattern?: string;\n\n      /**\n       * Content media type restriction.\n       */\n      contentMediaType?: string;\n\n      /**\n       * Minimum length restriction.\n       *\n       * @type uint64\n       */\n      minLength?: number;\n\n      /**\n       * Maximum length restriction.\n       *\n       * @type uint64\n       */\n      maxLength?: number;\n    }\n\n    /**\n     * Array type info.\n     */\n    export interface IArray extends __ISignificant<\"array\"> {\n      /**\n       * Items type info.\n       *\n       * The `items` means the type of the array elements. In other words, it is\n       * the type schema info of the `T` in the TypeScript array type `Array<T>`.\n       */\n      items: IJsonSchema;\n\n      /**\n       * Unique items restriction.\n       *\n       * If this property value is `true`, target array must have unique items.\n       */\n      uniqueItems?: boolean;\n\n      /**\n       * Minimum items restriction.\n       *\n       * Restriction of minumum number of items in the array.\n       *\n       * @type uint64\n       */\n      minItems?: number;\n\n      /**\n       * Maximum items restriction.\n       *\n       * Restriction of maximum number of items in the array.\n       *\n       * @type uint64\n       */\n      maxItems?: number;\n    }\n\n    /**\n     * Tuple type info.\n     */\n    export interface ITuple extends __ISignificant<\"array\"> {\n      /**\n       * Prefix items.\n       *\n       * The `prefixItems` means the type schema info of the prefix items in the\n       * tuple type. In the TypeScript, it is expressed as `[T1, T2]`.\n       *\n       * If you want to express `[T1, T2, ...TO[]]` type, you can configure the\n       * `...TO[]` through the {@link additionalItems} property.\n       */\n      prefixItems: IJsonSchema[];\n\n      /**\n       * Additional items.\n       *\n       * The `additionalItems` means the type schema info of the additional items\n       * after the {@link prefixItems}. In the TypeScript, if there's a type\n       * `[T1, T2, ...TO[]]`, the `...TO[]` is represented by the `additionalItems`.\n       *\n       * By the way, if you configure the `additionalItems` as `true`, it means\n       * the additional items are not restricted. They can be any type, so that\n       * it is equivalent to the TypeScript type `[T1, T2, ...any[]]`.\n       *\n       * Otherwise configure the `additionalItems` as the {@link IJsonSchema},\n       * it means the additional items must follow the type schema info.\n       * Therefore, it is equivalent to the TypeScript type `[T1, T2, ...TO[]]`.\n       */\n      additionalItems?: boolean | IJsonSchema;\n\n      /**\n       * Unique items restriction.\n       *\n       * If this property value is `true`, target tuple must have unique items.\n       */\n      uniqueItems?: boolean;\n\n      /**\n       * Minimum items restriction.\n       *\n       * Restriction of minumum number of items in the tuple.\n       *\n       * @type uint64\n       */\n      minItems?: number;\n\n      /**\n       * Maximum items restriction.\n       *\n       * Restriction of maximum number of items in the tuple.\n       *\n       * @type uint64\n       */\n      maxItems?: number;\n    }\n\n    /**\n     * Object type info.\n     */\n    export interface IObject extends __ISignificant<\"object\"> {\n      /**\n       * Properties of the object.\n       *\n       * The `properties` means a list of key-value pairs of the object's\n       * regular properties. The key is the name of the regular property,\n       * and the value is the type schema info.\n       *\n       * If you need additional properties that is represented by dynamic key,\n       * you can use the {@link additionalProperties} instead.\n       */\n      properties?: Record<string, IJsonSchema>;\n\n      /**\n       * Additional properties' info.\n       *\n       * The `additionalProperties` means the type schema info of the additional\n       * properties that are not listed in the {@link properties}.\n       *\n       * If the value is `true`, it means that the additional properties are not\n       * restricted. They can be any type. Otherwise, if the value is\n       * {@link IOpenAiSchema} type, it means that the additional properties must\n       * follow the type schema info.\n       *\n       * - `true`: `Record<string, any>`\n       * - `IOpenAiSchema`: `Record<string, T>`\n       */\n      additionalProperties?: boolean | IJsonSchema;\n\n      /**\n       * List of key values of the required properties.\n       *\n       * The `required` means a list of the key values of the required\n       * {@link properties}. If some property key is not listed in the `required`\n       * list, it means that property is optional. Otherwise some property key\n       * exists in the `required` list, it means that the property must be filled.\n       *\n       * Below is an example of the {@link properties} and `required`.\n       *\n       * ```typescript\n       * interface SomeObject {\n       *   id: string;\n       *   email: string;\n       *   name?: string;\n       * }\n       * ```\n       *\n       * As you can see, `id` and `email` {@link properties} are {@link required},\n       * so that they are listed in the `required` list.\n       *\n       * ```json\n       * {\n       *   \"type\": \"object\",\n       *   \"properties\": {\n       *     \"id\": { \"type\": \"string\" },\n       *     \"email\": { \"type\": \"string\" },\n       *     \"name\": { \"type\": \"string\" }\n       *   },\n       *   \"required\": [\"id\", \"email\"]\n       * }\n       * ```\n       */\n      required?: string[];\n    }\n\n    /**\n     * Reference type directing named schema.\n     */\n    export interface IReference<Key = string> extends __IAttribute {\n      /**\n       * Reference to the named schema.\n       *\n       * The `ref` is a reference to the named schema. Format of the `$ref` is\n       * following the JSON Pointer specification. In the OpenAPI, the `$ref`\n       * starts with `#/components/schemas/` which means the type is stored in\n       * the {@link OpenApi.IComponents.schemas} object.\n       *\n       * - `#/components/schemas/SomeObject`\n       * - `#/components/schemas/AnotherObject`\n       */\n      $ref: Key;\n    }\n\n    /**\n     * Union type.\n     *\n     * IOneOf` represents an union type of the TypeScript (`A | B | C`).\n     *\n     * For reference, even though your Swagger (or OpenAPI) document has\n     * defined `anyOf` instead of the `oneOf`, {@link OpenApi} forcibly\n     * converts it to `oneOf` type.\n     */\n    export interface IOneOf extends __IAttribute {\n      /**\n       * List of the union types.\n       */\n      oneOf: Exclude<IJsonSchema, IJsonSchema.IOneOf>[];\n\n      /**\n       * Discriminator info of the union type.\n       */\n      discriminator?: IOneOf.IDiscriminator;\n    }\n    export namespace IOneOf {\n      /**\n       * Discriminator info of the union type.\n       */\n      export interface IDiscriminator {\n        /**\n         * Property name for the discriminator.\n         */\n        propertyName: string;\n\n        /**\n         * Mapping of the discriminator value to the schema name.\n         *\n         * This property is valid only for {@link IReference} typed\n         * {@link IOneOf.oneof} elements. Therefore, `key` of `mapping` is\n         * the discriminator value, and `value` of `mapping` is the\n         * schema name like `#/components/schemas/SomeObject`.\n         */\n        mapping?: Record<string, string>;\n      }\n    }\n\n    /**\n     * Null type.\n     */\n    export interface INull extends __ISignificant<\"null\"> {\n      /**\n       * Default value.\n       */\n      default?: null;\n    }\n\n    /**\n     * Unknown, the `any` type.\n     */\n    export interface IUnknown extends __IAttribute {\n      /**\n       * Type is never be defined.\n       */\n      type?: undefined;\n    }\n\n    /**\n     * Significant attributes that can be applied to the most types.\n     */\n    export interface __ISignificant<Type extends string> extends __IAttribute {\n      /**\n       * Discriminator value of the type.\n       */\n      type: Type;\n    }\n\n    /**\n     * Common attributes that can be applied to all types.\n     */\n    export interface __IAttribute {\n      /**\n       * Title of the schema.\n       */\n      title?: string;\n\n      /**\n       * Detailed description of the schema.\n       */\n      description?: string;\n\n      /**\n       * Whether the type is deprecated or not.\n       */\n      deprecated?: boolean;\n\n      /**\n       * Example value.\n       */\n      example?: any;\n\n      /**\n       * List of example values as key-value pairs.\n       */\n      examples?: Record<string, any>;\n    }\n  }\n\n  /**\n   * Security scheme of Swagger Documents.\n   *\n   * `OpenApi.ISecurityScheme` is a data structure representing content of\n   * `securitySchemes` in `swagger.json` file. It is composed with 5 types of\n   * security schemes as an union type like below.\n   *\n   * @reference https://swagger.io/specification/#security-scheme-object\n   */\n  export type ISecurityScheme =\n    | ISecurityScheme.IApiKey\n    | ISecurityScheme.IHttpBasic\n    | ISecurityScheme.IHttpBearer\n    | ISecurityScheme.IOAuth2\n    | ISecurityScheme.IOpenId;\n  export namespace ISecurityScheme {\n    /**\n     * Normal API key type.\n     */\n    export interface IApiKey {\n      type: \"apiKey\";\n      in?: \"header\" | \"query\" | \"cookie\";\n      name?: string;\n      description?: string;\n    }\n\n    /**\n     * HTTP basic authentication type.\n     */\n    export interface IHttpBasic {\n      type: \"http\";\n      scheme: \"basic\";\n      description?: string;\n    }\n\n    /**\n     * HTTP bearer authentication type.\n     */\n    export interface IHttpBearer {\n      type: \"http\";\n      scheme: \"bearer\";\n      bearerFormat?: string;\n      description?: string;\n    }\n\n    /**\n     * OAuth2 authentication type.\n     */\n    export interface IOAuth2 {\n      type: \"oauth2\";\n      flows: IOAuth2.IFlowSet;\n      description?: string;\n    }\n    export interface IOpenId {\n      type: \"openIdConnect\";\n      openIdConnectUrl: string;\n      description?: string;\n    }\n    export namespace IOAuth2 {\n      export interface IFlowSet {\n        authorizationCode?: IFlow;\n        implicit?: Omit<IFlow, \"tokenUrl\">;\n        password?: Omit<IFlow, \"authorizationUrl\">;\n        clientCredentials?: Omit<IFlow, \"authorizationUrl\">;\n      }\n      export interface IFlow {\n        authorizationUrl?: string;\n        tokenUrl?: string;\n        refreshUrl?: string;\n        scopes?: Record<string, string>;\n      }\n    }\n  }\n}\n"],"names":["OpenApi","convert","input","OpenApiV3_1","is","OpenApiV3_1Emender","OpenApiV3","OpenApiV3Upgrader","SwaggerV2","SwaggerV2Upgrader","TypeError","downgrade","document","version","SwaggerV2Downgrader","OpenApiV3Downgrader"],"mappings":";;;;;;;;;;;;;;;;AA2CM,IAAWA;;CAAjB,SAAiBA;IAoBf,SAAgBC,QACdC;QAMA,IAAIC,YAAYC,GAAGF,QACjB,OAAOG,mBAAmBJ,QAAQC,aAC/B,IAAII,UAAUF,GAAGF,QACpB,OAAOK,kBAAkBN,QAAQC,aAC9B,IAAIM,UAAUJ,GAAGF,QACpB,OAAOO,kBAAkBR,QAAQC;QACnC,MAAM,IAAIQ,UAAU;;IAbNV,QAAAC;IA+ChB,SAAgBU,UACdC,UACAC;QAEA,IAAIA,YAAY,OAAO,OAAOC,oBAAoBH,UAAUC,gBACvD,IAAIC,YAAY,OAAO,OAAOE,oBAAoBJ,UAAUC;QACjE,MAAM,IAAIF,UAAU;;IANNV,QAAAW;AA4iCjB,EA/mCD,CAAiBX,YAAAA,UA+mChB,CAAA;;"}