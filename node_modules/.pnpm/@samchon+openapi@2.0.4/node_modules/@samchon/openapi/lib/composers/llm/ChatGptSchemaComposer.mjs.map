{"version":3,"file":"ChatGptSchemaComposer.mjs","sources":["../../../src/composers/llm/ChatGptSchemaComposer.ts"],"sourcesContent":["import { OpenApi } from \"../../OpenApi\";\nimport { IChatGptSchema } from \"../../structures/IChatGptSchema\";\nimport { ILlmFunction } from \"../../structures/ILlmFunction\";\nimport { ILlmSchemaV3_1 } from \"../../structures/ILlmSchemaV3_1\";\nimport { IOpenApiSchemaError } from \"../../structures/IOpenApiSchemaError\";\nimport { IResult } from \"../../typings/IResult\";\nimport { ChatGptTypeChecker } from \"../../utils/ChatGptTypeChecker\";\nimport { LlmTypeCheckerV3_1 } from \"../../utils/LlmTypeCheckerV3_1\";\nimport { OpenApiTypeChecker } from \"../../utils/OpenApiTypeChecker\";\nimport { LlmSchemaV3_1Composer } from \"./LlmSchemaV3_1Composer\";\n\nexport namespace ChatGptSchemaComposer {\n  export const parameters = (props: {\n    config: IChatGptSchema.IConfig;\n    components: OpenApi.IComponents;\n    schema: OpenApi.IJsonSchema.IObject | OpenApi.IJsonSchema.IReference;\n    accessor?: string;\n    refAccessor?: string;\n  }): IResult<IChatGptSchema.IParameters, IOpenApiSchemaError> => {\n    const result: IResult<ILlmSchemaV3_1.IParameters, IOpenApiSchemaError> =\n      LlmSchemaV3_1Composer.parameters({\n        ...props,\n        config: {\n          reference: props.config.reference,\n          constraint: false,\n        },\n        validate,\n      });\n    if (result.success === false) return result;\n    for (const key of Object.keys(result.value.$defs))\n      result.value.$defs[key] = transform(result.value.$defs[key]);\n    return {\n      success: true,\n      value: transform(result.value) as IChatGptSchema.IParameters,\n    };\n  };\n\n  export const schema = (props: {\n    config: IChatGptSchema.IConfig;\n    components: OpenApi.IComponents;\n    $defs: Record<string, IChatGptSchema>;\n    schema: OpenApi.IJsonSchema;\n    accessor?: string;\n    refAccessor?: string;\n  }): IResult<IChatGptSchema, IOpenApiSchemaError> => {\n    const oldbie: Set<string> = new Set(Object.keys(props.$defs));\n    const result: IResult<ILlmSchemaV3_1, IOpenApiSchemaError> =\n      LlmSchemaV3_1Composer.schema({\n        ...props,\n        config: {\n          reference: props.config.reference,\n          constraint: false,\n        },\n        validate,\n      });\n    if (result.success === false) return result;\n    for (const key of Object.keys(props.$defs))\n      if (oldbie.has(key) === false)\n        props.$defs[key] = transform(props.$defs[key]);\n    return {\n      success: true,\n      value: transform(result.value),\n    };\n  };\n\n  const validate = (\n    schema: OpenApi.IJsonSchema,\n    accessor: string,\n  ): IOpenApiSchemaError.IReason[] => {\n    if (OpenApiTypeChecker.isObject(schema) && !!schema.additionalProperties)\n      return [\n        {\n          schema: schema,\n          accessor: `${accessor}.additionalProperties`,\n          message:\n            \"ChatGPT does not allow additionalProperties, the dynamic key typed object.\",\n        },\n      ];\n    return [];\n  };\n\n  const transform = (schema: ILlmSchemaV3_1): IChatGptSchema => {\n    const union: Array<IChatGptSchema> = [];\n    const attribute: IChatGptSchema.__IAttribute = {\n      title: schema.title,\n      description: schema.description,\n      example: schema.example,\n      examples: schema.examples,\n      ...Object.fromEntries(\n        Object.entries(schema).filter(\n          ([key, value]) => key.startsWith(\"x-\") && value !== undefined,\n        ),\n      ),\n    };\n    const visit = (input: ILlmSchemaV3_1): void => {\n      if (LlmTypeCheckerV3_1.isOneOf(input)) input.oneOf.forEach(visit);\n      else if (LlmTypeCheckerV3_1.isArray(input))\n        union.push({\n          ...input,\n          items: transform(input.items),\n        });\n      else if (LlmTypeCheckerV3_1.isObject(input))\n        union.push({\n          ...input,\n          properties: Object.fromEntries(\n            Object.entries(input.properties).map(([key, value]) => [\n              key,\n              transform(value),\n            ]),\n          ),\n          additionalProperties: false,\n        });\n      else if (LlmTypeCheckerV3_1.isConstant(input) === false)\n        union.push(input);\n    };\n    const visitConstant = (input: ILlmSchemaV3_1): void => {\n      const insert = (value: any): void => {\n        const matched: IChatGptSchema.IString | undefined = union.find(\n          (u) =>\n            (u as IChatGptSchema.__ISignificant<any> | undefined)?.type ===\n            typeof value,\n        ) as IChatGptSchema.IString | undefined;\n        if (matched !== undefined) {\n          matched.enum ??= [];\n          matched.enum.push(value);\n        } else\n          union.push({\n            type: typeof value as \"number\",\n            enum: [value],\n          });\n      };\n      if (OpenApiTypeChecker.isConstant(input)) insert(input.const);\n      else if (OpenApiTypeChecker.isOneOf(input))\n        input.oneOf.forEach(visitConstant);\n    };\n    visit(schema);\n    visitConstant(schema);\n    if (union.length === 0)\n      return {\n        ...attribute,\n        type: undefined,\n      };\n    else if (union.length === 1)\n      return {\n        ...attribute,\n        ...union[0],\n        description: ChatGptTypeChecker.isReference(union[0]!)\n          ? undefined\n          : union[0].description,\n      };\n    return {\n      ...attribute,\n      anyOf: union.map((u) => ({\n        ...u,\n        description: ChatGptTypeChecker.isReference(u)\n          ? undefined\n          : u.description,\n      })),\n    };\n  };\n\n  export const separateParameters = (props: {\n    predicate: (schema: IChatGptSchema) => boolean;\n    parameters: IChatGptSchema.IParameters;\n  }): ILlmFunction.ISeparated<\"chatgpt\"> => {\n    const [llm, human] = separateObject({\n      $defs: props.parameters.$defs,\n      predicate: props.predicate,\n      schema: props.parameters,\n    });\n    if (llm === null || human === null)\n      return {\n        llm: llm as IChatGptSchema.IParameters | null,\n        human: human as IChatGptSchema.IParameters | null,\n      };\n    const output: ILlmFunction.ISeparated<\"chatgpt\"> = {\n      llm: {\n        ...llm,\n        $defs: Object.fromEntries(\n          Object.entries(props.parameters.$defs).filter(([key]) =>\n            key.endsWith(\".Llm\"),\n          ),\n        ),\n      },\n      human: {\n        ...human,\n        $defs: Object.fromEntries(\n          Object.entries(props.parameters.$defs).filter(([key]) =>\n            key.endsWith(\".Human\"),\n          ),\n        ),\n      },\n    };\n    for (const key of Object.keys(props.parameters.$defs))\n      if (key.endsWith(\".Llm\") === false && key.endsWith(\".Human\") === false)\n        delete props.parameters.$defs[key];\n    return output;\n  };\n\n  const separateStation = (props: {\n    $defs: Record<string, IChatGptSchema>;\n    predicate: (schema: IChatGptSchema) => boolean;\n    schema: IChatGptSchema;\n  }): [IChatGptSchema | null, IChatGptSchema | null] => {\n    if (props.predicate(props.schema) === true) return [null, props.schema];\n    else if (\n      ChatGptTypeChecker.isUnknown(props.schema) ||\n      ChatGptTypeChecker.isAnyOf(props.schema)\n    )\n      return [props.schema, null];\n    else if (ChatGptTypeChecker.isObject(props.schema))\n      return separateObject({\n        $defs: props.$defs,\n        predicate: props.predicate,\n        schema: props.schema,\n      });\n    else if (ChatGptTypeChecker.isArray(props.schema))\n      return separateArray({\n        $defs: props.$defs,\n        predicate: props.predicate,\n        schema: props.schema,\n      });\n    else if (ChatGptTypeChecker.isReference(props.schema))\n      return separateReference({\n        $defs: props.$defs,\n        predicate: props.predicate,\n        schema: props.schema,\n      });\n    return [props.schema, null];\n  };\n\n  const separateArray = (props: {\n    $defs: Record<string, IChatGptSchema>;\n    predicate: (schema: IChatGptSchema) => boolean;\n    schema: IChatGptSchema.IArray;\n  }): [IChatGptSchema.IArray | null, IChatGptSchema.IArray | null] => {\n    const [x, y] = separateStation({\n      $defs: props.$defs,\n      predicate: props.predicate,\n      schema: props.schema.items,\n    });\n    return [\n      x !== null\n        ? {\n            ...props.schema,\n            items: x,\n          }\n        : null,\n      y !== null\n        ? {\n            ...props.schema,\n            items: y,\n          }\n        : null,\n    ];\n  };\n\n  const separateObject = (props: {\n    $defs: Record<string, IChatGptSchema>;\n    predicate: (schema: IChatGptSchema) => boolean;\n    schema: IChatGptSchema.IObject;\n  }): [IChatGptSchema.IObject | null, IChatGptSchema.IObject | null] => {\n    // EMPTY OBJECT\n    if (\n      Object.keys(props.schema.properties ?? {}).length === 0 &&\n      !!props.schema.additionalProperties === false\n    )\n      return [props.schema, null];\n\n    const llm = {\n      ...props.schema,\n      properties: {} as Record<string, IChatGptSchema>,\n    } satisfies IChatGptSchema.IObject;\n    const human = {\n      ...props.schema,\n      properties: {} as Record<string, IChatGptSchema>,\n    } satisfies IChatGptSchema.IObject;\n\n    for (const [key, value] of Object.entries(props.schema.properties ?? {})) {\n      const [x, y] = separateStation({\n        $defs: props.$defs,\n        predicate: props.predicate,\n        schema: value,\n      });\n      if (x !== null) llm.properties[key] = x;\n      if (y !== null) human.properties[key] = y;\n    }\n    return [\n      Object.keys(llm.properties).length === 0 ? null : shrinkRequired(llm),\n      Object.keys(human.properties).length === 0 ? null : shrinkRequired(human),\n    ];\n  };\n\n  const separateReference = (props: {\n    $defs: Record<string, IChatGptSchema>;\n    predicate: (schema: IChatGptSchema) => boolean;\n    schema: IChatGptSchema.IReference;\n  }): [IChatGptSchema.IReference | null, IChatGptSchema.IReference | null] => {\n    const key: string = props.schema.$ref.split(\"#/$defs/\")[1];\n\n    // FIND EXISTING\n    if (props.$defs?.[`${key}.Human`] || props.$defs?.[`${key}.Llm`])\n      return [\n        props.$defs?.[`${key}.Llm`]\n          ? {\n              ...props.schema,\n              $ref: `#/$defs/${key}.Llm`,\n            }\n          : null,\n        props.$defs?.[`${key}.Human`]\n          ? {\n              ...props.schema,\n              $ref: `#/$defs/${key}.Human`,\n            }\n          : null,\n      ];\n\n    // PRE-ASSIGNMENT\n    props.$defs![`${key}.Llm`] = {};\n    props.$defs![`${key}.Human`] = {};\n\n    // DO COMPOSE\n    const schema: IChatGptSchema = props.$defs?.[key]!;\n    const [llm, human] = separateStation({\n      $defs: props.$defs,\n      predicate: props.predicate,\n      schema,\n    });\n\n    // ONLY ONE\n    if (llm === null || human === null) {\n      delete props.$defs[`${key}.Llm`];\n      delete props.$defs[`${key}.Human`];\n      return llm === null ? [null, props.schema] : [props.schema, null];\n    }\n\n    // BOTH OF THEM\n    return [\n      llm !== null\n        ? {\n            ...props.schema,\n            $ref: `#/$defs/${key}.Llm`,\n          }\n        : null,\n      human !== null\n        ? {\n            ...props.schema,\n            $ref: `#/$defs/${key}.Human`,\n          }\n        : null,\n    ];\n  };\n\n  const shrinkRequired = (\n    s: IChatGptSchema.IObject,\n  ): IChatGptSchema.IObject => {\n    s.required = s.required.filter((key) => s.properties?.[key] !== undefined);\n    return s;\n  };\n}\n"],"names":["ChatGptSchemaComposer","parameters","props","result","LlmSchemaV3_1Composer","config","reference","constraint","validate","success","key","Object","keys","value","$defs","transform","schema","oldbie","Set","has","accessor","OpenApiTypeChecker","isObject","additionalProperties","message","union","attribute","title","description","example","examples","fromEntries","entries","filter","startsWith","undefined","visit","input","LlmTypeCheckerV3_1","isOneOf","oneOf","forEach","isArray","push","items","properties","map","isConstant","visitConstant","insert","matched","find","u","type","enum","const","length","ChatGptTypeChecker","isReference","anyOf","separateParameters","llm","human","separateObject","predicate","output","endsWith","separateStation","isUnknown","isAnyOf","separateArray","separateReference","x","y","shrinkRequired","$ref","split","s","required"],"mappings":";;;;;;;;AAWM,IAAWA;;CAAjB,SAAiBA;IACFA,sBAAAC,aAAcC;QAOzB,MAAMC,SACJC,sBAAsBH,WAAW;eAC5BC;YACHG,QAAQ;gBACNC,WAAWJ,MAAMG,OAAOC;gBACxBC,YAAY;;YAEdC;;QAEJ,IAAIL,OAAOM,YAAY,OAAO,OAAON;QACrC,KAAK,MAAMO,OAAOC,OAAOC,KAAKT,OAAOU,MAAMC,QACzCX,OAAOU,MAAMC,MAAMJ,OAAOK,UAAUZ,OAAOU,MAAMC,MAAMJ;QACzD,OAAO;YACLD,SAAS;YACTI,OAAOE,UAAUZ,OAAOU;;AACzB;IAGUb,sBAAAgB,SAAUd;QAQrB,MAAMe,SAAsB,IAAIC,IAAIP,OAAOC,KAAKV,MAAMY;QACtD,MAAMX,SACJC,sBAAsBY,OAAO;eACxBd;YACHG,QAAQ;gBACNC,WAAWJ,MAAMG,OAAOC;gBACxBC,YAAY;;YAEdC;;QAEJ,IAAIL,OAAOM,YAAY,OAAO,OAAON;QACrC,KAAK,MAAMO,OAAOC,OAAOC,KAAKV,MAAMY,QAClC,IAAIG,OAAOE,IAAIT,SAAS,OACtBR,MAAMY,MAAMJ,OAAOK,UAAUb,MAAMY,MAAMJ;QAC7C,OAAO;YACLD,SAAS;YACTI,OAAOE,UAAUZ,OAAOU;;AACzB;IAGH,MAAML,WAAW,CACfQ,QACAI;QAEA,IAAIC,mBAAmBC,SAASN,aAAaA,OAAOO,sBAClD,OAAO,EACL;YACEP;YACAI,UAAU,GAAGA;YACbI,SACE;;QAGR,OAAO;AAAE;IAGX,MAAMT,YAAaC;QACjB,MAAMS,QAA+B;QACrC,MAAMC,YAAyC;YAC7CC,OAAOX,OAAOW;YACdC,aAAaZ,OAAOY;YACpBC,SAASb,OAAOa;YAChBC,UAAUd,OAAOc;eACdnB,OAAOoB,YACRpB,OAAOqB,QAAQhB,QAAQiB,QACrB,EAAEvB,KAAKG,WAAWH,IAAIwB,WAAW,SAASrB,UAAUsB;;QAI1D,MAAMC,QAASC;YACb,IAAIC,mBAAmBC,QAAQF,QAAQA,MAAMG,MAAMC,QAAQL,aACtD,IAAIE,mBAAmBI,QAAQL,QAClCZ,MAAMkB,KAAK;mBACNN;gBACHO,OAAO7B,UAAUsB,MAAMO;qBAEtB,IAAIN,mBAAmBhB,SAASe,QACnCZ,MAAMkB,KAAK;mBACNN;gBACHQ,YAAYlC,OAAOoB,YACjBpB,OAAOqB,QAAQK,MAAMQ,YAAYC,KAAI,EAAEpC,KAAKG,WAAW,EACrDH,KACAK,UAAUF;gBAGdU,sBAAsB;qBAErB,IAAIe,mBAAmBS,WAAWV,WAAW,OAChDZ,MAAMkB,KAAKN;AAAM;QAErB,MAAMW,gBAAiBX;YACrB,MAAMY,SAAUpC;gBACd,MAAMqC,UAA8CzB,MAAM0B,MACvDC,KACEA,GAAsDC,gBAChDxC;gBAEX,IAAIqC,YAAYf,WAAW;oBACzBe,QAAQI,SAARJ,QAAQI,OAAS;oBACjBJ,QAAQI,KAAKX,KAAK9B;uBAElBY,MAAMkB,KAAK;oBACTU,aAAaxC;oBACbyC,MAAM,EAACzC;;AACP;YAEN,IAAIQ,mBAAmB0B,WAAWV,QAAQY,OAAOZ,MAAMkB,aAClD,IAAIlC,mBAAmBkB,QAAQF,QAClCA,MAAMG,MAAMC,QAAQO;AAAc;QAEtCZ,MAAMpB;QACNgC,cAAchC;QACd,IAAIS,MAAM+B,WAAW,GACnB,OAAO;eACF9B;YACH2B,MAAMlB;gBAEL,IAAIV,MAAM+B,WAAW,GACxB,OAAO;eACF9B;eACAD,MAAM;YACTG,aAAa6B,mBAAmBC,YAAYjC,MAAM,MAC9CU,YACAV,MAAM,GAAGG;;QAEjB,OAAO;eACFF;YACHiC,OAAOlC,MAAMqB,KAAKM,MAAO;mBACpBA;gBACHxB,aAAa6B,mBAAmBC,YAAYN,KACxCjB,YACAiB,EAAExB;;;AAET;IAGU5B,sBAAA4D,qBAAsB1D;QAIjC,OAAO2D,KAAKC,SAASC,eAAe;YAClCjD,OAAOZ,MAAMD,WAAWa;YACxBkD,WAAW9D,MAAM8D;YACjBhD,QAAQd,MAAMD;;QAEhB,IAAI4D,QAAQ,QAAQC,UAAU,MAC5B,OAAO;YACLD;YACAC;;QAEJ,MAAMG,SAA6C;YACjDJ,KAAK;mBACAA;gBACH/C,OAAOH,OAAOoB,YACZpB,OAAOqB,QAAQ9B,MAAMD,WAAWa,OAAOmB,QAAO,EAAEvB,SAC9CA,IAAIwD,SAAS;;YAInBJ,OAAO;mBACFA;gBACHhD,OAAOH,OAAOoB,YACZpB,OAAOqB,QAAQ9B,MAAMD,WAAWa,OAAOmB,QAAO,EAAEvB,SAC9CA,IAAIwD,SAAS;;;QAKrB,KAAK,MAAMxD,OAAOC,OAAOC,KAAKV,MAAMD,WAAWa,QAC7C,IAAIJ,IAAIwD,SAAS,YAAY,SAASxD,IAAIwD,SAAS,cAAc,cACxDhE,MAAMD,WAAWa,MAAMJ;QAClC,OAAOuD;AAAM;IAGf,MAAME,kBAAmBjE;QAKvB,IAAIA,MAAM8D,UAAU9D,MAAMc,YAAY,MAAM,OAAO,EAAC,MAAMd,MAAMc,eAC3D,IACHyC,mBAAmBW,UAAUlE,MAAMc,WACnCyC,mBAAmBY,QAAQnE,MAAMc,SAEjC,OAAO,EAACd,MAAMc,QAAQ,aACnB,IAAIyC,mBAAmBnC,SAASpB,MAAMc,SACzC,OAAO+C,eAAe;YACpBjD,OAAOZ,MAAMY;YACbkD,WAAW9D,MAAM8D;YACjBhD,QAAQd,MAAMc;iBAEb,IAAIyC,mBAAmBf,QAAQxC,MAAMc,SACxC,OAAOsD,cAAc;YACnBxD,OAAOZ,MAAMY;YACbkD,WAAW9D,MAAM8D;YACjBhD,QAAQd,MAAMc;iBAEb,IAAIyC,mBAAmBC,YAAYxD,MAAMc,SAC5C,OAAOuD,kBAAkB;YACvBzD,OAAOZ,MAAMY;YACbkD,WAAW9D,MAAM8D;YACjBhD,QAAQd,MAAMc;;QAElB,OAAO,EAACd,MAAMc,QAAQ;AAAK;IAG7B,MAAMsD,gBAAiBpE;QAKrB,OAAOsE,GAAGC,KAAKN,gBAAgB;YAC7BrD,OAAOZ,MAAMY;YACbkD,WAAW9D,MAAM8D;YACjBhD,QAAQd,MAAMc,OAAO4B;;QAEvB,OAAO,EACL4B,MAAM,OACF;eACKtE,MAAMc;YACT4B,OAAO4B;YAET,MACJC,MAAM,OACF;eACKvE,MAAMc;YACT4B,OAAO6B;YAET;AACL;IAGH,MAAMV,iBAAkB7D;QAMtB,IACES,OAAOC,KAAKV,MAAMc,OAAO6B,cAAc,CAAE,GAAEW,WAAW,OACpDtD,MAAMc,OAAOO,yBAAyB,OAExC,OAAO,EAACrB,MAAMc,QAAQ;QAExB,MAAM6C,MAAM;eACP3D,MAAMc;YACT6B,YAAY,CAAoC;;QAElD,MAAMiB,QAAQ;eACT5D,MAAMc;YACT6B,YAAY,CAAoC;;QAGlD,KAAK,OAAOnC,KAAKG,UAAUF,OAAOqB,QAAQ9B,MAAMc,OAAO6B,cAAc,CAAA,IAAK;YACxE,OAAO2B,GAAGC,KAAKN,gBAAgB;gBAC7BrD,OAAOZ,MAAMY;gBACbkD,WAAW9D,MAAM8D;gBACjBhD,QAAQH;;YAEV,IAAI2D,MAAM,MAAMX,IAAIhB,WAAWnC,OAAO8D;YACtC,IAAIC,MAAM,MAAMX,MAAMjB,WAAWnC,OAAO+D;;QAE1C,OAAO,EACL9D,OAAOC,KAAKiD,IAAIhB,YAAYW,WAAW,IAAI,OAAOkB,eAAeb,MACjElD,OAAOC,KAAKkD,MAAMjB,YAAYW,WAAW,IAAI,OAAOkB,eAAeZ;AACpE;IAGH,MAAMS,oBAAqBrE;QAKzB,MAAMQ,MAAcR,MAAMc,OAAO2D,KAAKC,MAAM,YAAY;QAGxD,IAAI1E,MAAMY,QAAQ,GAAGJ,gBAAgBR,MAAMY,QAAQ,GAAGJ,YACpD,OAAO,EACLR,MAAMY,QAAQ,GAAGJ,aACb;eACKR,MAAMc;YACT2D,MAAM,WAAWjE;YAEnB,MACJR,MAAMY,QAAQ,GAAGJ,eACb;eACKR,MAAMc;YACT2D,MAAM,WAAWjE;YAEnB;QAIRR,MAAMY,MAAO,GAAGJ,aAAa,CAAE;QAC/BR,MAAMY,MAAO,GAAGJ,eAAe,CAAE;QAGjC,MAAMM,SAAyBd,MAAMY,QAAQJ;QAC7C,OAAOmD,KAAKC,SAASK,gBAAgB;YACnCrD,OAAOZ,MAAMY;YACbkD,WAAW9D,MAAM8D;YACjBhD;;QAIF,IAAI6C,QAAQ,QAAQC,UAAU,MAAM;mBAC3B5D,MAAMY,MAAM,GAAGJ;mBACfR,MAAMY,MAAM,GAAGJ;YACtB,OAAOmD,QAAQ,OAAO,EAAC,MAAM3D,MAAMc,WAAU,EAACd,MAAMc,QAAQ;;QAI9D,OAAO,EACL6C,QAAQ,OACJ;eACK3D,MAAMc;YACT2D,MAAM,WAAWjE;YAEnB,MACJoD,UAAU,OACN;eACK5D,MAAMc;YACT2D,MAAM,WAAWjE;YAEnB;AACL;IAGH,MAAMgE,iBACJG;QAEAA,EAAEC,WAAWD,EAAEC,SAAS7C,QAAQvB,OAAQmE,EAAEhC,aAAanC,SAASyB;QAChE,OAAO0C;AAAC;AAEX,EA5VD,CAAiB7E,0BAAAA,wBA4VhB,CAAA;;"}