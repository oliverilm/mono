"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeminiSchemaComposer = void 0;
var LlmTypeCheckerV3_1 = require("../../utils/LlmTypeCheckerV3");
var OpenApiTypeChecker_1 = require("../../utils/OpenApiTypeChecker");
var LlmParametersComposer_1 = require("./LlmParametersComposer");
var LlmSchemaV3Composer_1 = require("./LlmSchemaV3Composer");
var GeminiSchemaComposer;
(function (GeminiSchemaComposer) {
    GeminiSchemaComposer.parameters = function (props) {
        var entity = LlmParametersComposer_1.LlmParametersFinder.parameters(__assign(__assign({}, props), { method: "GeminiSchemaComposer.parameters" }));
        if (entity.success === false)
            return entity;
        return GeminiSchemaComposer.schema(__assign(__assign({}, props), { schema: entity.value }));
    };
    GeminiSchemaComposer.schema = function (props) {
        // TRANSFORM TO LLM SCHEMA OF V3.0
        var result = LlmSchemaV3Composer_1.LlmSchemaV3Composer.schema(__assign(__assign({}, props), { config: {
                recursive: props.config.recursive,
                constraint: false,
            }, validate: function (next, accessor) {
                if (OpenApiTypeChecker_1.OpenApiTypeChecker.isObject(next)) {
                    if (!!next.additionalProperties)
                        return [
                            {
                                schema: next,
                                accessor: "".concat(accessor, ".additionalProperties"),
                                message: "Gemini does not allow additionalProperties.",
                            },
                        ];
                }
                else if (OpenApiTypeChecker_1.OpenApiTypeChecker.isOneOf(next) &&
                    isOneOf(props.components)(next))
                    return [
                        {
                            schema: next,
                            accessor: accessor,
                            message: "Gemini does not allow union type.",
                        },
                    ];
                return [];
            } }));
        if (result.success === false)
            return result;
        // SPECIALIZATIONS
        LlmTypeCheckerV3_1.LlmTypeCheckerV3.visit({
            schema: result.value,
            closure: function (v) {
                if (v.title !== undefined) {
                    if (v.description === undefined)
                        v.description = v.title;
                    else {
                        var title = v.title.endsWith(".")
                            ? v.title.substring(0, v.title.length - 1)
                            : v.title;
                        v.description = v.description.startsWith(title)
                            ? v.description
                            : "".concat(title, ".\n\n").concat(v.description);
                    }
                    delete v.title;
                }
                if (LlmTypeCheckerV3_1.LlmTypeCheckerV3.isObject(v) &&
                    v.additionalProperties !== undefined) {
                    delete v.additionalProperties;
                }
            },
        });
        // DO NOT ALLOW UNION TYPE
        return result;
    };
    GeminiSchemaComposer.separateParameters = function (props) {
        return LlmSchemaV3Composer_1.LlmSchemaV3Composer.separateParameters(props);
    };
})(GeminiSchemaComposer || (exports.GeminiSchemaComposer = GeminiSchemaComposer = {}));
var isOneOf = function (components) {
    return function (schema) {
        var union = [];
        var already = new Set();
        var visit = function (schema) {
            var _a;
            if (OpenApiTypeChecker_1.OpenApiTypeChecker.isBoolean(schema) ||
                OpenApiTypeChecker_1.OpenApiTypeChecker.isInteger(schema) ||
                OpenApiTypeChecker_1.OpenApiTypeChecker.isNumber(schema) ||
                OpenApiTypeChecker_1.OpenApiTypeChecker.isString(schema))
                union.push(__assign({}, schema));
            else if (OpenApiTypeChecker_1.OpenApiTypeChecker.isArray(schema) ||
                OpenApiTypeChecker_1.OpenApiTypeChecker.isTuple(schema) ||
                OpenApiTypeChecker_1.OpenApiTypeChecker.isObject(schema))
                union.push(schema);
            else if (OpenApiTypeChecker_1.OpenApiTypeChecker.isOneOf(schema))
                schema.oneOf.forEach(visit);
            else if (OpenApiTypeChecker_1.OpenApiTypeChecker.isReference(schema)) {
                if (already.has(schema.$ref))
                    union.push(schema);
                else {
                    already.add(schema.$ref);
                    var target = (_a = components.schemas) === null || _a === void 0 ? void 0 : _a[schema.$ref.split("/").pop()];
                    if (target === undefined)
                        union.push(schema);
                    else
                        visit(target);
                }
            }
        };
        var visitConstant = function (schema) {
            var e_1, _a;
            var insert = function (value) {
                var _a;
                var matched = union.find(function (u) {
                    return u.type ===
                        typeof value;
                });
                if (matched !== undefined) {
                    (_a = matched.enum) !== null && _a !== void 0 ? _a : (matched.enum = []);
                    matched.enum.push(value);
                }
                else
                    union.push({ type: typeof value, enum: [value] });
            };
            if (OpenApiTypeChecker_1.OpenApiTypeChecker.isConstant(schema))
                insert(schema.const);
            else if (OpenApiTypeChecker_1.OpenApiTypeChecker.isOneOf(schema))
                try {
                    for (var _b = __values(schema.oneOf), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var u = _c.value;
                        if (OpenApiTypeChecker_1.OpenApiTypeChecker.isConstant(u))
                            insert(u.const);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
        };
        visit(schema);
        visitConstant(schema);
        return union.length > 1;
    };
};
