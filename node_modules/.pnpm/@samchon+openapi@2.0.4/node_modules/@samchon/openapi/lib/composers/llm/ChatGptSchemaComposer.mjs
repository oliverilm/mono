import { ChatGptTypeChecker } from "../../utils/ChatGptTypeChecker.mjs";

import { LlmTypeCheckerV3_1 } from "../../utils/LlmTypeCheckerV3_1.mjs";

import { OpenApiTypeChecker } from "../../utils/OpenApiTypeChecker.mjs";

import { LlmSchemaV3_1Composer } from "./LlmSchemaV3_1Composer.mjs";

var ChatGptSchemaComposer;

(function(ChatGptSchemaComposer) {
    ChatGptSchemaComposer.parameters = props => {
        const result = LlmSchemaV3_1Composer.parameters({
            ...props,
            config: {
                reference: props.config.reference,
                constraint: false
            },
            validate
        });
        if (result.success === false) return result;
        for (const key of Object.keys(result.value.$defs)) result.value.$defs[key] = transform(result.value.$defs[key]);
        return {
            success: true,
            value: transform(result.value)
        };
    };
    ChatGptSchemaComposer.schema = props => {
        const oldbie = new Set(Object.keys(props.$defs));
        const result = LlmSchemaV3_1Composer.schema({
            ...props,
            config: {
                reference: props.config.reference,
                constraint: false
            },
            validate
        });
        if (result.success === false) return result;
        for (const key of Object.keys(props.$defs)) if (oldbie.has(key) === false) props.$defs[key] = transform(props.$defs[key]);
        return {
            success: true,
            value: transform(result.value)
        };
    };
    const validate = (schema, accessor) => {
        if (OpenApiTypeChecker.isObject(schema) && !!schema.additionalProperties) return [ {
            schema,
            accessor: `${accessor}.additionalProperties`,
            message: "ChatGPT does not allow additionalProperties, the dynamic key typed object."
        } ];
        return [];
    };
    const transform = schema => {
        const union = [];
        const attribute = {
            title: schema.title,
            description: schema.description,
            example: schema.example,
            examples: schema.examples,
            ...Object.fromEntries(Object.entries(schema).filter((([key, value]) => key.startsWith("x-") && value !== undefined)))
        };
        const visit = input => {
            if (LlmTypeCheckerV3_1.isOneOf(input)) input.oneOf.forEach(visit); else if (LlmTypeCheckerV3_1.isArray(input)) union.push({
                ...input,
                items: transform(input.items)
            }); else if (LlmTypeCheckerV3_1.isObject(input)) union.push({
                ...input,
                properties: Object.fromEntries(Object.entries(input.properties).map((([key, value]) => [ key, transform(value) ]))),
                additionalProperties: false
            }); else if (LlmTypeCheckerV3_1.isConstant(input) === false) union.push(input);
        };
        const visitConstant = input => {
            const insert = value => {
                const matched = union.find((u => u?.type === typeof value));
                if (matched !== undefined) {
                    matched.enum ?? (matched.enum = []);
                    matched.enum.push(value);
                } else union.push({
                    type: typeof value,
                    enum: [ value ]
                });
            };
            if (OpenApiTypeChecker.isConstant(input)) insert(input.const); else if (OpenApiTypeChecker.isOneOf(input)) input.oneOf.forEach(visitConstant);
        };
        visit(schema);
        visitConstant(schema);
        if (union.length === 0) return {
            ...attribute,
            type: undefined
        }; else if (union.length === 1) return {
            ...attribute,
            ...union[0],
            description: ChatGptTypeChecker.isReference(union[0]) ? undefined : union[0].description
        };
        return {
            ...attribute,
            anyOf: union.map((u => ({
                ...u,
                description: ChatGptTypeChecker.isReference(u) ? undefined : u.description
            })))
        };
    };
    ChatGptSchemaComposer.separateParameters = props => {
        const [llm, human] = separateObject({
            $defs: props.parameters.$defs,
            predicate: props.predicate,
            schema: props.parameters
        });
        if (llm === null || human === null) return {
            llm,
            human
        };
        const output = {
            llm: {
                ...llm,
                $defs: Object.fromEntries(Object.entries(props.parameters.$defs).filter((([key]) => key.endsWith(".Llm"))))
            },
            human: {
                ...human,
                $defs: Object.fromEntries(Object.entries(props.parameters.$defs).filter((([key]) => key.endsWith(".Human"))))
            }
        };
        for (const key of Object.keys(props.parameters.$defs)) if (key.endsWith(".Llm") === false && key.endsWith(".Human") === false) delete props.parameters.$defs[key];
        return output;
    };
    const separateStation = props => {
        if (props.predicate(props.schema) === true) return [ null, props.schema ]; else if (ChatGptTypeChecker.isUnknown(props.schema) || ChatGptTypeChecker.isAnyOf(props.schema)) return [ props.schema, null ]; else if (ChatGptTypeChecker.isObject(props.schema)) return separateObject({
            $defs: props.$defs,
            predicate: props.predicate,
            schema: props.schema
        }); else if (ChatGptTypeChecker.isArray(props.schema)) return separateArray({
            $defs: props.$defs,
            predicate: props.predicate,
            schema: props.schema
        }); else if (ChatGptTypeChecker.isReference(props.schema)) return separateReference({
            $defs: props.$defs,
            predicate: props.predicate,
            schema: props.schema
        });
        return [ props.schema, null ];
    };
    const separateArray = props => {
        const [x, y] = separateStation({
            $defs: props.$defs,
            predicate: props.predicate,
            schema: props.schema.items
        });
        return [ x !== null ? {
            ...props.schema,
            items: x
        } : null, y !== null ? {
            ...props.schema,
            items: y
        } : null ];
    };
    const separateObject = props => {
        if (Object.keys(props.schema.properties ?? {}).length === 0 && !!props.schema.additionalProperties === false) return [ props.schema, null ];
        const llm = {
            ...props.schema,
            properties: {}
        };
        const human = {
            ...props.schema,
            properties: {}
        };
        for (const [key, value] of Object.entries(props.schema.properties ?? {})) {
            const [x, y] = separateStation({
                $defs: props.$defs,
                predicate: props.predicate,
                schema: value
            });
            if (x !== null) llm.properties[key] = x;
            if (y !== null) human.properties[key] = y;
        }
        return [ Object.keys(llm.properties).length === 0 ? null : shrinkRequired(llm), Object.keys(human.properties).length === 0 ? null : shrinkRequired(human) ];
    };
    const separateReference = props => {
        const key = props.schema.$ref.split("#/$defs/")[1];
        if (props.$defs?.[`${key}.Human`] || props.$defs?.[`${key}.Llm`]) return [ props.$defs?.[`${key}.Llm`] ? {
            ...props.schema,
            $ref: `#/$defs/${key}.Llm`
        } : null, props.$defs?.[`${key}.Human`] ? {
            ...props.schema,
            $ref: `#/$defs/${key}.Human`
        } : null ];
        props.$defs[`${key}.Llm`] = {};
        props.$defs[`${key}.Human`] = {};
        const schema = props.$defs?.[key];
        const [llm, human] = separateStation({
            $defs: props.$defs,
            predicate: props.predicate,
            schema
        });
        if (llm === null || human === null) {
            delete props.$defs[`${key}.Llm`];
            delete props.$defs[`${key}.Human`];
            return llm === null ? [ null, props.schema ] : [ props.schema, null ];
        }
        return [ llm !== null ? {
            ...props.schema,
            $ref: `#/$defs/${key}.Llm`
        } : null, human !== null ? {
            ...props.schema,
            $ref: `#/$defs/${key}.Human`
        } : null ];
    };
    const shrinkRequired = s => {
        s.required = s.required.filter((key => s.properties?.[key] !== undefined));
        return s;
    };
})(ChatGptSchemaComposer || (ChatGptSchemaComposer = {}));

export { ChatGptSchemaComposer };
//# sourceMappingURL=ChatGptSchemaComposer.mjs.map
