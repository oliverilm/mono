{"version":3,"file":"MigrateRouteAccessor.mjs","sources":["../../../src/composers/migrate/MigrateRouteAccessor.ts"],"sourcesContent":["import { IHttpMigrateRoute } from \"../../structures/IHttpMigrateRoute\";\nimport { EndpointUtil } from \"../../utils/EndpointUtil\";\nimport { Escaper } from \"../../utils/Escaper\";\nimport { MapUtil } from \"../../utils/MapUtil\";\n\nexport namespace MigrateRouteAccessor {\n  export const overwrite = (routes: IHttpMigrateRoute[]): void => {\n    const dict: Map<string, IElement> = collect((op) =>\n      op.emendedPath\n        .split(\"/\")\n        .filter((str) => !!str.length && str[0] !== \":\")\n        .map(EndpointUtil.normalize)\n        .map((str) => (Escaper.variable(str) ? str : `_${str}`)),\n    )(routes) as Map<string, IElement>;\n    for (const props of dict.values())\n      props.entries.forEach((entry, i) => {\n        entry.alias = EndpointUtil.escapeDuplicate(\n          [\n            ...props.children,\n            ...props.entries.filter((_, j) => i !== j).map((e) => e.alias),\n          ].map(EndpointUtil.normalize),\n        )(EndpointUtil.normalize(entry.alias));\n        entry.route.accessor = [...props.namespace, entry.alias];\n\n        const parameters: { name: string; key: string }[] = [\n          ...entry.route.parameters,\n          ...(entry.route.body ? [entry.route.body] : []),\n          ...(entry.route.headers ? [entry.route.headers] : []),\n          ...(entry.route.query ? [entry.route.query] : []),\n        ];\n        parameters.forEach(\n          (p, i) =>\n            (p.key = EndpointUtil.escapeDuplicate([\n              \"connection\",\n              entry.alias,\n              ...parameters.filter((_, j) => i !== j).map((y) => y.key),\n            ])(p.key)),\n        );\n      });\n  };\n\n  const collect =\n    (getter: (r: IHttpMigrateRoute) => string[]) =>\n    (routes: IHttpMigrateRoute[]): Map<string, IElement> => {\n      const dict: Map<string, IElement> = new Map();\n      for (const r of routes) {\n        const namespace: string[] = getter(r);\n        let last: IElement = MapUtil.take(dict)(namespace.join(\".\"))(() => ({\n          namespace,\n          children: new Set(),\n          entries: [],\n        }));\n        last.entries.push({\n          route: r,\n          alias: getName(r),\n        });\n        namespace.slice(0, -1).forEach((_i, i, array) => {\n          const partial: string[] = namespace.slice(0, array.length - i);\n          const element: IElement = MapUtil.take(dict)(partial.join(\".\"))(\n            () => ({\n              namespace: partial,\n              children: new Set(),\n              entries: [],\n            }),\n          );\n          element.children.add(last.namespace.at(-1)!);\n        });\n        const top = MapUtil.take(dict)(\"\")(() => ({\n          namespace: [],\n          children: new Set(),\n          entries: [],\n        }));\n        if (namespace.length) top.children.add(namespace[0]);\n      }\n      return dict;\n    };\n\n  const getName = (op: IHttpMigrateRoute): string => {\n    const method = op.method === \"delete\" ? \"erase\" : op.method;\n    if (op.parameters.length === 0) return method;\n    return (\n      method +\n      \"By\" +\n      op.parameters.map((p) => EndpointUtil.capitalize(p.key)).join(\"And\")\n    );\n  };\n\n  interface IElement {\n    namespace: string[];\n    entries: IEntry[];\n    children: Set<string>;\n  }\n  interface IEntry {\n    route: IHttpMigrateRoute;\n    alias: string;\n  }\n}\n"],"names":["MigrateRouteAccessor","overwrite","routes","dict","collect","op","emendedPath","split","filter","str","length","map","EndpointUtil","normalize","Escaper","variable","props","values","entries","forEach","entry","i","alias","escapeDuplicate","children","_","j","e","route","accessor","namespace","parameters","body","headers","query","p","key","y","getter","Map","r","last","MapUtil","take","join","Set","push","getName","slice","_i","array","partial","element","add","at","top","method","capitalize"],"mappings":";;;;;;AAKM,IAAWA;;CAAjB,SAAiBA;IACFA,qBAAAC,YAAaC;QACxB,MAAMC,OAA8BC,SAASC,MAC3CA,GAAGC,YACAC,MAAM,KACNC,QAAQC,SAAUA,IAAIC,UAAUD,IAAI,OAAO,MAC3CE,IAAIC,aAAaC,WACjBF,KAAKF,OAASK,QAAQC,SAASN,OAAOA,MAAM,IAAIA,SALjBL,CAMlCF;QACF,KAAK,MAAMc,SAASb,KAAKc,UACvBD,MAAME,QAAQC,SAAQ,CAACC,OAAOC;YAC5BD,MAAME,QAAQV,aAAaW,gBACzB,KACKP,MAAMQ,aACNR,MAAME,QAAQV,QAAO,CAACiB,GAAGC,MAAML,MAAMK,IAAGf,KAAKgB,KAAMA,EAAEL,UACxDX,IAAIC,aAAaC,WAJPD,CAKZA,aAAaC,UAAUO,MAAME;YAC/BF,MAAMQ,MAAMC,WAAW,KAAIb,MAAMc,WAAWV,MAAME;YAElD,MAAMS,aAA8C,KAC/CX,MAAMQ,MAAMG,eACXX,MAAMQ,MAAMI,OAAO,EAACZ,MAAMQ,MAAMI,SAAQ,OACxCZ,MAAMQ,MAAMK,UAAU,EAACb,MAAMQ,MAAMK,YAAW,OAC9Cb,MAAMQ,MAAMM,QAAQ,EAACd,MAAMQ,MAAMM,UAAS;YAEhDH,WAAWZ,SACT,CAACgB,GAAGd,MACDc,EAAEC,MAAMxB,aAAaW,gBAAgB,EACpC,cACAH,MAAME,UACHS,WAAWvB,QAAO,CAACiB,GAAGC,MAAML,MAAMK,IAAGf,KAAK0B,KAAMA,EAAED,QAH9CxB,CAINuB,EAAEC;AACR;AACD;IAGN,MAAMhC,UACHkC,UACApC;QACC,MAAMC,OAA8B,IAAIoC;QACxC,KAAK,MAAMC,KAAKtC,QAAQ;YACtB,MAAM4B,YAAsBQ,OAAOE;YACnC,IAAIC,OAAiBC,QAAQC,KAAKxC,KAAbuC,CAAmBZ,UAAUc,KAAK,KAAlCF,EAAwC,OAAO;gBAClEZ;gBACAN,UAAU,IAAIqB;gBACd3B,SAAS;;YAEXuB,KAAKvB,QAAQ4B,KAAK;gBAChBlB,OAAOY;gBACPlB,OAAOyB,QAAQP;;YAEjBV,UAAUkB,MAAM,IAAI,GAAG7B,SAAQ,CAAC8B,IAAI5B,GAAG6B;gBACrC,MAAMC,UAAoBrB,UAAUkB,MAAM,GAAGE,MAAMxC,SAASW;gBAC5D,MAAM+B,UAAoBV,QAAQC,KAAKxC,KAAbuC,CAAmBS,QAAQP,KAAK,KAAhCF,EACxB,OAAO;oBACLZ,WAAWqB;oBACX3B,UAAU,IAAIqB;oBACd3B,SAAS;;gBAGbkC,QAAQ5B,SAAS6B,IAAIZ,KAAKX,UAAUwB,IAAI;AAAI;YAE9C,MAAMC,MAAMb,QAAQC,KAAKxC,KAAbuC,CAAmB,GAAnBA,EAAuB,OAAO;gBACxCZ,WAAW;gBACXN,UAAU,IAAIqB;gBACd3B,SAAS;;YAEX,IAAIY,UAAUpB,QAAQ6C,IAAI/B,SAAS6B,IAAIvB,UAAU;;QAEnD,OAAO3B;AAAI;IAGf,MAAM4C,UAAW1C;QACf,MAAMmD,SAASnD,GAAGmD,WAAW,WAAW,UAAUnD,GAAGmD;QACrD,IAAInD,GAAG0B,WAAWrB,WAAW,GAAG,OAAO8C;QACvC,OACEA,SACA,OACAnD,GAAG0B,WAAWpB,KAAKwB,KAAMvB,aAAa6C,WAAWtB,EAAEC,OAAMQ,KAAK;AAAM;AAazE,EA3FD,CAAiB5C,yBAAAA,uBA2FhB,CAAA;;"}