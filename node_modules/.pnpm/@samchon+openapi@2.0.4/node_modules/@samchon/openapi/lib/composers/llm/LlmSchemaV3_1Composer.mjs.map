{"version":3,"file":"LlmSchemaV3_1Composer.mjs","sources":["../../../src/composers/llm/LlmSchemaV3_1Composer.ts"],"sourcesContent":["import { OpenApi } from \"../../OpenApi\";\nimport { ILlmFunction } from \"../../structures/ILlmFunction\";\nimport { ILlmSchemaV3_1 } from \"../../structures/ILlmSchemaV3_1\";\nimport { IOpenApiSchemaError } from \"../../structures/IOpenApiSchemaError\";\nimport { IResult } from \"../../typings/IResult\";\nimport { LlmTypeCheckerV3_1 } from \"../../utils/LlmTypeCheckerV3_1\";\nimport { OpenApiContraintShifter } from \"../../utils/OpenApiContraintShifter\";\nimport { OpenApiTypeChecker } from \"../../utils/OpenApiTypeChecker\";\nimport { JsonDescriptionUtil } from \"../../utils/internal/JsonDescriptionUtil\";\nimport { LlmParametersFinder } from \"./LlmParametersComposer\";\n\nexport namespace LlmSchemaV3_1Composer {\n  export const parameters = (props: {\n    config: ILlmSchemaV3_1.IConfig;\n    components: OpenApi.IComponents;\n    schema: OpenApi.IJsonSchema.IObject | OpenApi.IJsonSchema.IReference;\n    errors?: string[];\n    /** @internal */\n    validate?: (\n      input: OpenApi.IJsonSchema,\n      accessor: string,\n    ) => IOpenApiSchemaError.IReason[];\n    accessor?: string;\n    refAccessor?: string;\n  }): IResult<ILlmSchemaV3_1.IParameters, IOpenApiSchemaError> => {\n    const entity: IResult<OpenApi.IJsonSchema.IObject, IOpenApiSchemaError> =\n      LlmParametersFinder.parameters({\n        ...props,\n        method: \"LlmSchemaV3_1Composer.parameters\",\n      });\n    if (entity.success === false) return entity;\n\n    const $defs: Record<string, ILlmSchemaV3_1> = {};\n    const result: IResult<ILlmSchemaV3_1, IOpenApiSchemaError> = schema({\n      ...props,\n      $defs,\n      schema: entity.value,\n    });\n    if (result.success === false) return result;\n    return {\n      success: true,\n      value: {\n        ...(result.value as ILlmSchemaV3_1.IObject),\n        additionalProperties: false,\n        $defs,\n      } satisfies ILlmSchemaV3_1.IParameters,\n    };\n  };\n\n  export const schema = (props: {\n    config: ILlmSchemaV3_1.IConfig;\n    components: OpenApi.IComponents;\n    $defs: Record<string, ILlmSchemaV3_1>;\n    schema: OpenApi.IJsonSchema;\n    /** @internal */\n    validate?: (\n      input: OpenApi.IJsonSchema,\n      accessor: string,\n    ) => IOpenApiSchemaError.IReason[];\n    accessor?: string;\n    refAccessor?: string;\n  }): IResult<ILlmSchemaV3_1, IOpenApiSchemaError> => {\n    const union: Array<ILlmSchemaV3_1 | null> = [];\n    const attribute: ILlmSchemaV3_1.__IAttribute = {\n      title: props.schema.title,\n      description: props.schema.description,\n      example: props.schema.example,\n      examples: props.schema.examples,\n      ...Object.fromEntries(\n        Object.entries(props.schema).filter(\n          ([key, value]) => key.startsWith(\"x-\") && value !== undefined,\n        ),\n      ),\n    };\n\n    const reasons: IOpenApiSchemaError.IReason[] = [];\n    OpenApiTypeChecker.visit({\n      closure: (next, accessor) => {\n        if (props.validate) {\n          // CUSTOM VALIDATION\n          reasons.push(...props.validate(next, accessor));\n        }\n        if (OpenApiTypeChecker.isTuple(next))\n          reasons.push({\n            schema: next,\n            accessor: accessor,\n            message: `LLM does not allow tuple type.`,\n          });\n        else if (OpenApiTypeChecker.isReference(next)) {\n          // UNABLE TO FIND MATCHED REFERENCE\n          const key = next.$ref.split(\"#/components/schemas/\")[1];\n          if (props.components.schemas?.[key] === undefined)\n            reasons.push({\n              schema: next,\n              accessor: accessor,\n              message: `unable to find reference type ${JSON.stringify(key)}.`,\n            });\n        }\n      },\n      components: props.components,\n      schema: props.schema,\n      accessor: props.accessor,\n      refAccessor: props.refAccessor,\n    });\n    if (reasons.length > 0)\n      return {\n        success: false,\n        error: {\n          method: \"LlmSchemaV3_1Composer.schema\",\n          message: \"Failed to compose LLM schema of v3.1\",\n          reasons,\n        },\n      };\n\n    const visit = (input: OpenApi.IJsonSchema, accessor: string): number => {\n      if (OpenApiTypeChecker.isOneOf(input)) {\n        // UNION TYPE\n        input.oneOf.forEach((s, i) => visit(s, `${accessor}.oneOf[${i}]`));\n        return 0;\n      } else if (OpenApiTypeChecker.isReference(input)) {\n        // REFERENCE TYPE\n        const key: string = input.$ref.split(\"#/components/schemas/\")[1];\n        const target: OpenApi.IJsonSchema | undefined =\n          props.components.schemas?.[key];\n        if (target === undefined)\n          return union.push(null); // UNREACHABLEE\n        else if (\n          // KEEP THE REFERENCE TYPE\n          props.config.reference === true ||\n          OpenApiTypeChecker.isRecursiveReference({\n            components: props.components,\n            schema: input,\n          })\n        ) {\n          const out = () =>\n            union.push({\n              ...input,\n              $ref: `#/$defs/${key}`,\n            });\n          if (props.$defs[key] !== undefined) return out();\n          props.$defs[key] = {};\n          const converted: IResult<ILlmSchemaV3_1, IOpenApiSchemaError> =\n            schema({\n              config: props.config,\n              components: props.components,\n              $defs: props.$defs,\n              schema: target,\n              refAccessor: props.refAccessor,\n              accessor: `${props.refAccessor ?? \"$def\"}[${JSON.stringify(key)}]`,\n            });\n          if (converted.success === false) return union.push(null); // UNREACHABLE\n          props.$defs[key] = converted.value;\n          return out();\n        } else {\n          // DISCARD THE REFERENCE TYPE\n          const length: number = union.length;\n          visit(target, accessor);\n          if (length === union.length - 1 && union[union.length - 1] !== null)\n            union[union.length - 1] = {\n              ...union[union.length - 1]!,\n              description: JsonDescriptionUtil.cascade({\n                prefix: \"#/components/schemas/\",\n                components: props.components,\n                $ref: input.$ref,\n                description: union[union.length - 1]!.description,\n                escape: true,\n              }),\n            };\n          else\n            attribute.description = JsonDescriptionUtil.cascade({\n              prefix: \"#/components/schemas/\",\n              components: props.components,\n              $ref: input.$ref,\n              description: attribute.description,\n              escape: true,\n            });\n          return union.length;\n        }\n      } else if (OpenApiTypeChecker.isObject(input)) {\n        // OBJECT TYPE\n        const properties: Record<string, ILlmSchemaV3_1 | null> =\n          Object.entries(input.properties ?? {}).reduce(\n            (acc, [key, value]) => {\n              const converted: IResult<ILlmSchemaV3_1, IOpenApiSchemaError> =\n                schema({\n                  config: props.config,\n                  components: props.components,\n                  $defs: props.$defs,\n                  schema: value,\n                  refAccessor: props.refAccessor,\n                  accessor: `${accessor}.properties[${JSON.stringify(key)}]`,\n                });\n              acc[key] = converted.success ? converted.value : null;\n              if (converted.success === false)\n                reasons.push(...converted.error.reasons);\n              return acc;\n            },\n            {} as Record<string, ILlmSchemaV3_1 | null>,\n          );\n        if (Object.values(properties).some((v) => v === null))\n          return union.push(null);\n        const additionalProperties:\n          | ILlmSchemaV3_1\n          | boolean\n          | null\n          | undefined = (() => {\n          if (\n            typeof input.additionalProperties === \"object\" &&\n            input.additionalProperties !== null\n          ) {\n            const converted: IResult<ILlmSchemaV3_1, IOpenApiSchemaError> =\n              schema({\n                config: props.config,\n                components: props.components,\n                $defs: props.$defs,\n                schema: input.additionalProperties,\n                refAccessor: props.refAccessor,\n                accessor: `${accessor}.additionalProperties`,\n              });\n            if (converted.success === false) {\n              reasons.push(...converted.error.reasons);\n              return null;\n            }\n            return converted.value;\n          }\n          return input.additionalProperties;\n        })();\n        if (additionalProperties === null) return union.push(null);\n        return union.push({\n          ...input,\n          properties: properties as Record<string, ILlmSchemaV3_1>,\n          additionalProperties,\n          required: Object.keys(properties),\n        });\n      } else if (OpenApiTypeChecker.isArray(input)) {\n        const items: IResult<ILlmSchemaV3_1, IOpenApiSchemaError> = schema({\n          config: props.config,\n          components: props.components,\n          $defs: props.$defs,\n          schema: input.items,\n          refAccessor: props.refAccessor,\n          accessor: `${accessor}.items`,\n        });\n        if (items.success === false) {\n          reasons.push(...items.error.reasons);\n          return union.push(null);\n        }\n        return union.push(\n          (props.config.constraint\n            ? (x: ILlmSchemaV3_1.IArray) => x\n            : (x: ILlmSchemaV3_1.IArray) =>\n                OpenApiContraintShifter.shiftArray(x))({\n            ...input,\n            items: items.value,\n          }),\n        );\n      } else if (OpenApiTypeChecker.isString(input))\n        return union.push(\n          (props.config.constraint\n            ? (x: ILlmSchemaV3_1.IString) => x\n            : (x: ILlmSchemaV3_1.IString) =>\n                OpenApiContraintShifter.shiftString(x))({\n            ...input,\n          }),\n        );\n      else if (\n        OpenApiTypeChecker.isNumber(input) ||\n        OpenApiTypeChecker.isInteger(input)\n      )\n        return union.push(\n          (props.config.constraint\n            ? (x: ILlmSchemaV3_1.INumber | ILlmSchemaV3_1.IInteger) => x\n            : (x: ILlmSchemaV3_1.INumber | ILlmSchemaV3_1.IInteger) =>\n                OpenApiContraintShifter.shiftNumeric(x))({\n            ...input,\n          }),\n        );\n      else if (OpenApiTypeChecker.isTuple(input))\n        return union.push(null); // UNREACHABLE\n      else return union.push({ ...input });\n    };\n    visit(props.schema, props.accessor ?? \"$input.schema\");\n\n    if (union.some((u) => u === null))\n      return {\n        success: false,\n        error: {\n          method: \"LlmSchemaV3_1Composer.schema\",\n          message: \"Failed to compose LLM schema of v3.1\",\n          reasons,\n        },\n      };\n    else if (union.length === 0)\n      return {\n        success: true,\n        value: {\n          ...attribute,\n          type: undefined,\n        },\n      };\n    else if (union.length === 1)\n      return {\n        success: true,\n        value: {\n          ...attribute,\n          ...union[0]!,\n          description: LlmTypeCheckerV3_1.isReference(union[0]!)\n            ? undefined\n            : union[0]!.description,\n        },\n      };\n    return {\n      success: true,\n      value: {\n        ...attribute,\n        oneOf: union.map((u) => ({\n          ...u!,\n          description: LlmTypeCheckerV3_1.isReference(u!)\n            ? undefined\n            : u!.description,\n        })),\n      },\n    };\n  };\n\n  export const separateParameters = (props: {\n    predicate: (schema: ILlmSchemaV3_1) => boolean;\n    parameters: ILlmSchemaV3_1.IParameters;\n  }): ILlmFunction.ISeparated<\"3.1\"> => {\n    const [llm, human] = separateObject({\n      $defs: props.parameters.$defs,\n      predicate: props.predicate,\n      schema: props.parameters,\n    });\n    if (llm === null || human === null)\n      return {\n        llm: llm as ILlmSchemaV3_1.IParameters | null,\n        human: human as ILlmSchemaV3_1.IParameters | null,\n      };\n    const output: ILlmFunction.ISeparated<\"3.1\"> = {\n      llm: {\n        ...llm,\n        $defs: Object.fromEntries(\n          Object.entries(props.parameters.$defs).filter(([key]) =>\n            key.endsWith(\".Llm\"),\n          ),\n        ),\n      },\n      human: {\n        ...human,\n        $defs: Object.fromEntries(\n          Object.entries(props.parameters.$defs).filter(([key]) =>\n            key.endsWith(\".Human\"),\n          ),\n        ),\n      },\n    };\n    for (const key of Object.keys(props.parameters.$defs))\n      if (key.endsWith(\".Llm\") === false && key.endsWith(\".Human\") === false)\n        delete props.parameters.$defs[key];\n    return output;\n  };\n\n  const separateStation = (props: {\n    $defs: Record<string, ILlmSchemaV3_1>;\n    predicate: (schema: ILlmSchemaV3_1) => boolean;\n    schema: ILlmSchemaV3_1;\n  }): [ILlmSchemaV3_1 | null, ILlmSchemaV3_1 | null] => {\n    if (props.predicate(props.schema) === true) return [null, props.schema];\n    else if (\n      LlmTypeCheckerV3_1.isUnknown(props.schema) ||\n      LlmTypeCheckerV3_1.isOneOf(props.schema)\n    )\n      return [props.schema, null];\n    else if (LlmTypeCheckerV3_1.isObject(props.schema))\n      return separateObject({\n        $defs: props.$defs,\n        predicate: props.predicate,\n        schema: props.schema,\n      });\n    else if (LlmTypeCheckerV3_1.isArray(props.schema))\n      return separateArray({\n        $defs: props.$defs,\n        predicate: props.predicate,\n        schema: props.schema,\n      });\n    else if (LlmTypeCheckerV3_1.isReference(props.schema))\n      return separateReference({\n        $defs: props.$defs,\n        predicate: props.predicate,\n        schema: props.schema,\n      });\n    return [props.schema, null];\n  };\n\n  const separateArray = (props: {\n    $defs: Record<string, ILlmSchemaV3_1>;\n    predicate: (schema: ILlmSchemaV3_1) => boolean;\n    schema: ILlmSchemaV3_1.IArray;\n  }): [ILlmSchemaV3_1.IArray | null, ILlmSchemaV3_1.IArray | null] => {\n    const [x, y] = separateStation({\n      $defs: props.$defs,\n      predicate: props.predicate,\n      schema: props.schema.items,\n    });\n    return [\n      x !== null\n        ? {\n            ...props.schema,\n            items: x,\n          }\n        : null,\n      y !== null\n        ? {\n            ...props.schema,\n            items: y,\n          }\n        : null,\n    ];\n  };\n\n  const separateObject = (props: {\n    $defs: Record<string, ILlmSchemaV3_1>;\n    predicate: (schema: ILlmSchemaV3_1) => boolean;\n    schema: ILlmSchemaV3_1.IObject;\n  }): [ILlmSchemaV3_1.IObject | null, ILlmSchemaV3_1.IObject | null] => {\n    // EMPTY OBJECT\n    if (\n      Object.keys(props.schema.properties ?? {}).length === 0 &&\n      !!props.schema.additionalProperties === false\n    )\n      return [props.schema, null];\n\n    const llm = {\n      ...props.schema,\n      properties: {} as Record<string, ILlmSchemaV3_1>,\n      additionalProperties: props.schema.additionalProperties,\n    } satisfies ILlmSchemaV3_1.IObject;\n    const human = {\n      ...props.schema,\n      properties: {} as Record<string, ILlmSchemaV3_1>,\n    } satisfies ILlmSchemaV3_1.IObject;\n\n    for (const [key, value] of Object.entries(props.schema.properties ?? {})) {\n      const [x, y] = separateStation({\n        $defs: props.$defs,\n        predicate: props.predicate,\n        schema: value,\n      });\n      if (x !== null) llm.properties[key] = x;\n      if (y !== null) human.properties[key] = y;\n    }\n    if (\n      typeof props.schema.additionalProperties === \"object\" &&\n      props.schema.additionalProperties !== null\n    ) {\n      const [dx, dy] = separateStation({\n        $defs: props.$defs,\n        predicate: props.predicate,\n        schema: props.schema.additionalProperties,\n      });\n      llm.additionalProperties = dx ?? false;\n      human.additionalProperties = dy ?? false;\n    }\n    return [\n      !!Object.keys(llm.properties).length || !!llm.additionalProperties\n        ? shrinkRequired(llm)\n        : null,\n      !!Object.keys(human.properties).length || human.additionalProperties\n        ? shrinkRequired(human)\n        : null,\n    ];\n  };\n\n  const separateReference = (props: {\n    $defs: Record<string, ILlmSchemaV3_1>;\n    predicate: (schema: ILlmSchemaV3_1) => boolean;\n    schema: ILlmSchemaV3_1.IReference;\n  }): [ILlmSchemaV3_1.IReference | null, ILlmSchemaV3_1.IReference | null] => {\n    const key: string = props.schema.$ref.split(\"#/$defs/\")[1];\n\n    // FIND EXISTING\n    if (props.$defs?.[`${key}.Human`] || props.$defs?.[`${key}.Llm`])\n      return [\n        props.$defs?.[`${key}.Llm`]\n          ? {\n              ...props.schema,\n              $ref: `#/$defs/${key}.Llm`,\n            }\n          : null,\n        props.$defs?.[`${key}.Human`]\n          ? {\n              ...props.schema,\n              $ref: `#/$defs/${key}.Human`,\n            }\n          : null,\n      ];\n\n    // PRE-ASSIGNMENT\n    props.$defs![`${key}.Llm`] = {};\n    props.$defs![`${key}.Human`] = {};\n\n    // DO COMPOSE\n    const schema: ILlmSchemaV3_1 = props.$defs?.[key]!;\n    const [llm, human] = separateStation({\n      $defs: props.$defs,\n      predicate: props.predicate,\n      schema,\n    });\n\n    // ONLY ONE\n    if (llm === null || human === null) {\n      delete props.$defs[`${key}.Llm`];\n      delete props.$defs[`${key}.Human`];\n      return llm === null ? [null, props.schema] : [props.schema, null];\n    }\n\n    // FINALIZE\n    return [\n      llm !== null\n        ? {\n            ...props.schema,\n            $ref: `#/$defs/${key}.Llm`,\n          }\n        : null,\n      human !== null\n        ? {\n            ...props.schema,\n            $ref: `#/$defs/${key}.Human`,\n          }\n        : null,\n    ];\n  };\n\n  const shrinkRequired = (\n    s: ILlmSchemaV3_1.IObject,\n  ): ILlmSchemaV3_1.IObject => {\n    if (s.required !== undefined)\n      s.required = s.required.filter(\n        (key) => s.properties?.[key] !== undefined,\n      );\n    return s;\n  };\n}\n"],"names":["LlmSchemaV3_1Composer","parameters","props","entity","LlmParametersFinder","method","success","$defs","result","schema","value","additionalProperties","union","attribute","title","description","example","examples","Object","fromEntries","entries","filter","key","startsWith","undefined","reasons","OpenApiTypeChecker","visit","closure","next","accessor","validate","push","isTuple","message","isReference","$ref","split","components","schemas","JSON","stringify","refAccessor","length","error","input","isOneOf","oneOf","forEach","s","i","target","config","reference","isRecursiveReference","out","converted","JsonDescriptionUtil","cascade","prefix","escape","isObject","properties","reduce","acc","values","some","v","required","keys","isArray","items","constraint","x","OpenApiContraintShifter","shiftArray","isString","shiftString","isNumber","isInteger","shiftNumeric","u","type","LlmTypeCheckerV3_1","map","separateParameters","llm","human","separateObject","predicate","output","endsWith","separateStation","isUnknown","separateArray","separateReference","y","dx","dy","shrinkRequired"],"mappings":"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"}