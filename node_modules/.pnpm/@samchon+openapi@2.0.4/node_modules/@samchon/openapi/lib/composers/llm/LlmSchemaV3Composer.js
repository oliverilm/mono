"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LlmSchemaV3Composer = void 0;
var OpenApiV3Downgrader_1 = require("../../converters/OpenApiV3Downgrader");
var LlmTypeCheckerV3_1 = require("../../utils/LlmTypeCheckerV3");
var OpenApiContraintShifter_1 = require("../../utils/OpenApiContraintShifter");
var OpenApiTypeChecker_1 = require("../../utils/OpenApiTypeChecker");
var LlmParametersComposer_1 = require("./LlmParametersComposer");
var LlmSchemaV3Composer;
(function (LlmSchemaV3Composer) {
    LlmSchemaV3Composer.parameters = function (props) {
        var entity = LlmParametersComposer_1.LlmParametersFinder.parameters(__assign(__assign({}, props), { method: "LlmSchemaV3Composer.parameters" }));
        if (entity.success === false)
            return entity;
        var result = LlmSchemaV3Composer.schema(__assign(__assign({}, props), { schema: entity.value }));
        if (result.success === false)
            return result;
        return {
            success: true,
            value: __assign(__assign({}, result.value), { additionalProperties: false }),
        };
    };
    LlmSchemaV3Composer.schema = function (props) {
        // CHECK TUPLE TYPE
        var reasons = [];
        OpenApiTypeChecker_1.OpenApiTypeChecker.visit({
            closure: function (next, accessor) {
                var _a;
                if (props.validate)
                    reasons.push.apply(reasons, __spreadArray([], __read(props.validate(next, accessor)), false));
                if (OpenApiTypeChecker_1.OpenApiTypeChecker.isTuple(next))
                    reasons.push({
                        accessor: accessor,
                        schema: next,
                        message: "LLM does not allow tuple type.",
                    });
                else if (OpenApiTypeChecker_1.OpenApiTypeChecker.isReference(next)) {
                    // UNABLE TO FIND MATCHED REFERENCE
                    var key = next.$ref.split("#/components/schemas/")[1];
                    if (((_a = props.components.schemas) === null || _a === void 0 ? void 0 : _a[key]) === undefined) {
                        reasons.push({
                            schema: next,
                            message: "".concat(accessor, ": unable to find reference type ").concat(JSON.stringify(key), "."),
                            accessor: accessor,
                        });
                    }
                }
            },
            components: props.components,
            schema: props.schema,
            accessor: props.accessor,
            refAccessor: props.refAccessor,
        });
        // if ((valid as boolean) === false) return null;
        if (reasons.length > 0)
            return {
                success: false,
                error: {
                    method: "LlmSchemaV3Composer.schema",
                    message: "Failed to compose LLM schema of v3",
                    reasons: reasons,
                },
            };
        // CHECK MISMATCHES
        var escaped = OpenApiTypeChecker_1.OpenApiTypeChecker.escape(__assign(__assign({}, props), { recursive: props.config.recursive }));
        if (escaped.success === false)
            // UNREACHABLE
            return {
                success: false,
                error: {
                    method: "LlmSchemaV3Composer.schema",
                    message: "Failed to compose LLM schema of v3",
                    reasons: escaped.error.reasons,
                },
            };
        // SPECIALIZATIONS
        var downgraded = OpenApiV3Downgrader_1.OpenApiV3Downgrader.downgradeSchema({
            original: {
                schemas: {},
            },
            downgraded: {},
        })(escaped.value);
        LlmTypeCheckerV3_1.LlmTypeCheckerV3.visit({
            closure: function (next) {
                var _a, _b;
                if (LlmTypeCheckerV3_1.LlmTypeCheckerV3.isOneOf(next) &&
                    next.discriminator !== undefined)
                    delete next.discriminator;
                else if (LlmTypeCheckerV3_1.LlmTypeCheckerV3.isObject(next)) {
                    (_a = next.properties) !== null && _a !== void 0 ? _a : (next.properties = {});
                    (_b = next.required) !== null && _b !== void 0 ? _b : (next.required = []);
                }
                if (props.config.constraint === false) {
                    if (LlmTypeCheckerV3_1.LlmTypeCheckerV3.isInteger(next) ||
                        LlmTypeCheckerV3_1.LlmTypeCheckerV3.isNumber(next))
                        OpenApiContraintShifter_1.OpenApiContraintShifter.shiftNumeric(next);
                    else if (LlmTypeCheckerV3_1.LlmTypeCheckerV3.isString(next))
                        OpenApiContraintShifter_1.OpenApiContraintShifter.shiftString(next);
                    else if (LlmTypeCheckerV3_1.LlmTypeCheckerV3.isArray(next))
                        OpenApiContraintShifter_1.OpenApiContraintShifter.shiftArray(next);
                }
            },
            schema: downgraded,
        });
        return {
            success: true,
            value: downgraded,
        };
    };
    LlmSchemaV3Composer.separateParameters = function (props) {
        var _a = __read(separateObject({
            predicate: props.predicate,
            schema: props.parameters,
        }), 2), llm = _a[0], human = _a[1];
        return { llm: llm, human: human };
    };
    var separateStation = function (props) {
        if (props.predicate(props.schema) === true)
            return [null, props.schema];
        else if (LlmTypeCheckerV3_1.LlmTypeCheckerV3.isUnknown(props.schema) ||
            LlmTypeCheckerV3_1.LlmTypeCheckerV3.isOneOf(props.schema))
            return [props.schema, null];
        else if (LlmTypeCheckerV3_1.LlmTypeCheckerV3.isObject(props.schema))
            return separateObject({
                predicate: props.predicate,
                schema: props.schema,
            });
        else if (LlmTypeCheckerV3_1.LlmTypeCheckerV3.isArray(props.schema))
            return separateArray({
                predicate: props.predicate,
                schema: props.schema,
            });
        return [props.schema, null];
    };
    var separateArray = function (props) {
        var _a = __read(separateStation({
            predicate: props.predicate,
            schema: props.schema.items,
        }), 2), x = _a[0], y = _a[1];
        return [
            x !== null
                ? __assign(__assign({}, props.schema), { items: x }) : null,
            y !== null
                ? __assign(__assign({}, props.schema), { items: y }) : null,
        ];
    };
    var separateObject = function (props) {
        var e_1, _a;
        var _b, _c;
        // EMPTY OBJECT
        if (Object.keys((_b = props.schema.properties) !== null && _b !== void 0 ? _b : {}).length === 0 &&
            !!props.schema.additionalProperties === false)
            return [props.schema, null];
        var llm = __assign(__assign({}, props.schema), { properties: {}, additionalProperties: props.schema.additionalProperties });
        var human = __assign(__assign({}, props.schema), { properties: {}, additionalProperties: props.schema.additionalProperties });
        try {
            for (var _d = __values(Object.entries((_c = props.schema.properties) !== null && _c !== void 0 ? _c : {})), _e = _d.next(); !_e.done; _e = _d.next()) {
                var _f = __read(_e.value, 2), key = _f[0], value = _f[1];
                var _g = __read(separateStation({
                    predicate: props.predicate,
                    schema: value,
                }), 2), x = _g[0], y = _g[1];
                if (x !== null)
                    llm.properties[key] = x;
                if (y !== null)
                    human.properties[key] = y;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (typeof props.schema.additionalProperties === "object" &&
            props.schema.additionalProperties !== null) {
            var _h = __read(separateStation({
                predicate: props.predicate,
                schema: props.schema.additionalProperties,
            }), 2), dx = _h[0], dy = _h[1];
            llm.additionalProperties = dx !== null && dx !== void 0 ? dx : false;
            human.additionalProperties = dy !== null && dy !== void 0 ? dy : false;
        }
        return [
            !!Object.keys(llm.properties).length || !!llm.additionalProperties
                ? shrinkRequired(llm)
                : null,
            !!Object.keys(human.properties).length || !!human.additionalProperties
                ? shrinkRequired(human)
                : null,
        ];
    };
    var shrinkRequired = function (s) {
        s.required = s.required.filter(function (key) { return s.properties[key] !== undefined; });
        return s;
    };
})(LlmSchemaV3Composer || (exports.LlmSchemaV3Composer = LlmSchemaV3Composer = {}));
