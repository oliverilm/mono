import { LlmSchemaComposer } from "./LlmSchemaComposer.mjs";

var HttpLlmComposer;

(function(HttpLlmComposer) {
    HttpLlmComposer.application = props => {
        const errors = props.migrate.errors.filter((e => e.operation()["x-samchon-human"] !== true)).map((e => ({
            method: e.method,
            path: e.path,
            messages: e.messages,
            operation: () => e.operation(),
            route: () => undefined
        })));
        const functions = props.migrate.routes.filter((e => e.operation()["x-samchon-human"] !== true)).map(((route, i) => {
            if (route.method === "head") {
                errors.push({
                    method: route.method,
                    path: route.path,
                    messages: [ "HEAD method is not supported in the LLM application." ],
                    operation: () => route.operation(),
                    route: () => route
                });
                return null;
            } else if (route.body?.type === "multipart/form-data" || route.success?.type === "multipart/form-data") {
                errors.push({
                    method: route.method,
                    path: route.path,
                    messages: [ `The "multipart/form-data" content type is not supported in the LLM application.` ],
                    operation: () => route.operation(),
                    route: () => route
                });
                return null;
            }
            const localErrors = [];
            const func = composeFunction({
                model: props.model,
                options: props.options,
                components: props.migrate.document().components,
                route,
                errors: localErrors,
                index: i
            });
            if (func === null) errors.push({
                method: route.method,
                path: route.path,
                messages: localErrors,
                operation: () => route.operation(),
                route: () => route
            });
            return func;
        })).filter((v => v !== null));
        return {
            model: props.model,
            options: props.options,
            functions,
            errors
        };
    };
    const composeFunction = props => {
        const $defs = {};
        const cast = (s, accessor) => {
            const result = LlmSchemaComposer.schema(props.model)({
                config: props.options,
                schema: s,
                components: props.components,
                $defs,
                accessor,
                refAccessor: `$input.components.schemas`
            });
            if (result.success === false) {
                props.errors.push(...result.error.reasons.map((r => `${r.accessor}: ${r.message}`)));
                return null;
            }
            return result.value;
        };
        const endpoint = `$input.paths[${JSON.stringify(props.route.path)}][${JSON.stringify(props.route.method)}]`;
        const output = props.route.success ? cast(props.route.success.schema, `${endpoint}.responses[${JSON.stringify(props.route.success.status)}][${JSON.stringify(props.route.success.type)}].schema`) : undefined;
        const properties = [ ...props.route.parameters.map((s => [ s.key, cast({
            ...s.schema,
            title: s.parameter().title ?? s.schema.title,
            description: s.parameter().description ?? s.schema.description
        }, `${endpoint}.parameters[${JSON.stringify(s.key)}].schema`) ])), ...props.route.query ? [ [ props.route.query.key, cast({
            ...props.route.query.schema,
            title: props.route.query.title() ?? props.route.query.schema.title,
            description: props.route.query.description() ?? props.route.query.schema.description
        }, `${endpoint}.parameters[${JSON.stringify(props.route.query.key)}].schema`) ] ] : [], ...props.route.body ? [ [ props.route.body.key, cast({
            ...props.route.body.schema,
            description: props.route.body.description() ?? props.route.body.schema.description
        }, `${endpoint}.requestBody.content[${JSON.stringify(props.route.body.type)}].schema`) ] ] : [] ];
        if (output === null || properties.some((([_k, v]) => v === null))) return null;
        const parameters = {
            type: "object",
            properties: Object.fromEntries(properties),
            additionalProperties: false,
            required: properties.map((([k]) => k))
        };
        if (Object.keys($defs).length) parameters.$defs = $defs;
        const operation = props.route.operation();
        return {
            method: props.route.method,
            path: props.route.path,
            name: props.route.accessor.join("_"),
            strict: true,
            parameters,
            separated: props.options.separate ? LlmSchemaComposer.separateParameters(props.model)({
                predicate: props.options.separate,
                parameters
            }) : undefined,
            output,
            description: (() => {
                if (!operation.summary?.length || !operation.description?.length) return operation.summary || operation.description;
                const summary = operation.summary.endsWith(".") ? operation.summary.slice(0, -1) : operation.summary;
                return operation.description.startsWith(summary) ? operation.description : summary + ".\n\n" + operation.description;
            })(),
            deprecated: operation.deprecated,
            tags: operation.tags,
            route: () => props.route,
            operation: () => props.route.operation()
        };
    };
})(HttpLlmComposer || (HttpLlmComposer = {}));

export { HttpLlmComposer };
//# sourceMappingURL=HttpLlmApplicationComposer.mjs.map
