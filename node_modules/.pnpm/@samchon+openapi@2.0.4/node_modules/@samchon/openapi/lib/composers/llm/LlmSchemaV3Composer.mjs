import { OpenApiV3Downgrader } from "../../converters/OpenApiV3Downgrader.mjs";

import { LlmTypeCheckerV3 } from "../../utils/LlmTypeCheckerV3.mjs";

import { OpenApiContraintShifter } from "../../utils/OpenApiContraintShifter.mjs";

import { OpenApiTypeChecker } from "../../utils/OpenApiTypeChecker.mjs";

import { LlmParametersFinder } from "./LlmParametersComposer.mjs";

var LlmSchemaV3Composer;

(function(LlmSchemaV3Composer) {
    LlmSchemaV3Composer.parameters = props => {
        const entity = LlmParametersFinder.parameters({
            ...props,
            method: "LlmSchemaV3Composer.parameters"
        });
        if (entity.success === false) return entity;
        const result = LlmSchemaV3Composer.schema({
            ...props,
            schema: entity.value
        });
        if (result.success === false) return result;
        return {
            success: true,
            value: {
                ...result.value,
                additionalProperties: false
            }
        };
    };
    LlmSchemaV3Composer.schema = props => {
        const reasons = [];
        OpenApiTypeChecker.visit({
            closure: (next, accessor) => {
                if (props.validate) reasons.push(...props.validate(next, accessor));
                if (OpenApiTypeChecker.isTuple(next)) reasons.push({
                    accessor,
                    schema: next,
                    message: "LLM does not allow tuple type."
                }); else if (OpenApiTypeChecker.isReference(next)) {
                    const key = next.$ref.split("#/components/schemas/")[1];
                    if (props.components.schemas?.[key] === undefined) {
                        reasons.push({
                            schema: next,
                            message: `${accessor}: unable to find reference type ${JSON.stringify(key)}.`,
                            accessor
                        });
                    }
                }
            },
            components: props.components,
            schema: props.schema,
            accessor: props.accessor,
            refAccessor: props.refAccessor
        });
        if (reasons.length > 0) return {
            success: false,
            error: {
                method: "LlmSchemaV3Composer.schema",
                message: "Failed to compose LLM schema of v3",
                reasons
            }
        };
        const escaped = OpenApiTypeChecker.escape({
            ...props,
            recursive: props.config.recursive
        });
        if (escaped.success === false) return {
            success: false,
            error: {
                method: "LlmSchemaV3Composer.schema",
                message: "Failed to compose LLM schema of v3",
                reasons: escaped.error.reasons
            }
        };
        const downgraded = OpenApiV3Downgrader.downgradeSchema({
            original: {
                schemas: {}
            },
            downgraded: {}
        })(escaped.value);
        LlmTypeCheckerV3.visit({
            closure: next => {
                if (LlmTypeCheckerV3.isOneOf(next) && next.discriminator !== undefined) delete next.discriminator; else if (LlmTypeCheckerV3.isObject(next)) {
                    next.properties ?? (next.properties = {});
                    next.required ?? (next.required = []);
                }
                if (props.config.constraint === false) {
                    if (LlmTypeCheckerV3.isInteger(next) || LlmTypeCheckerV3.isNumber(next)) OpenApiContraintShifter.shiftNumeric(next); else if (LlmTypeCheckerV3.isString(next)) OpenApiContraintShifter.shiftString(next); else if (LlmTypeCheckerV3.isArray(next)) OpenApiContraintShifter.shiftArray(next);
                }
            },
            schema: downgraded
        });
        return {
            success: true,
            value: downgraded
        };
    };
    LlmSchemaV3Composer.separateParameters = props => {
        const [llm, human] = separateObject({
            predicate: props.predicate,
            schema: props.parameters
        });
        return {
            llm,
            human
        };
    };
    const separateStation = props => {
        if (props.predicate(props.schema) === true) return [ null, props.schema ]; else if (LlmTypeCheckerV3.isUnknown(props.schema) || LlmTypeCheckerV3.isOneOf(props.schema)) return [ props.schema, null ]; else if (LlmTypeCheckerV3.isObject(props.schema)) return separateObject({
            predicate: props.predicate,
            schema: props.schema
        }); else if (LlmTypeCheckerV3.isArray(props.schema)) return separateArray({
            predicate: props.predicate,
            schema: props.schema
        });
        return [ props.schema, null ];
    };
    const separateArray = props => {
        const [x, y] = separateStation({
            predicate: props.predicate,
            schema: props.schema.items
        });
        return [ x !== null ? {
            ...props.schema,
            items: x
        } : null, y !== null ? {
            ...props.schema,
            items: y
        } : null ];
    };
    const separateObject = props => {
        if (Object.keys(props.schema.properties ?? {}).length === 0 && !!props.schema.additionalProperties === false) return [ props.schema, null ];
        const llm = {
            ...props.schema,
            properties: {},
            additionalProperties: props.schema.additionalProperties
        };
        const human = {
            ...props.schema,
            properties: {},
            additionalProperties: props.schema.additionalProperties
        };
        for (const [key, value] of Object.entries(props.schema.properties ?? {})) {
            const [x, y] = separateStation({
                predicate: props.predicate,
                schema: value
            });
            if (x !== null) llm.properties[key] = x;
            if (y !== null) human.properties[key] = y;
        }
        if (typeof props.schema.additionalProperties === "object" && props.schema.additionalProperties !== null) {
            const [dx, dy] = separateStation({
                predicate: props.predicate,
                schema: props.schema.additionalProperties
            });
            llm.additionalProperties = dx ?? false;
            human.additionalProperties = dy ?? false;
        }
        return [ !!Object.keys(llm.properties).length || !!llm.additionalProperties ? shrinkRequired(llm) : null, !!Object.keys(human.properties).length || !!human.additionalProperties ? shrinkRequired(human) : null ];
    };
    const shrinkRequired = s => {
        s.required = s.required.filter((key => s.properties[key] !== undefined));
        return s;
    };
})(LlmSchemaV3Composer || (LlmSchemaV3Composer = {}));

export { LlmSchemaV3Composer };
//# sourceMappingURL=LlmSchemaV3Composer.mjs.map
