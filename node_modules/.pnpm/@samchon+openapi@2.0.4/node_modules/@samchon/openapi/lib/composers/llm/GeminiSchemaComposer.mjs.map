{"version":3,"file":"GeminiSchemaComposer.mjs","sources":["../../../src/composers/llm/GeminiSchemaComposer.ts"],"sourcesContent":["import { OpenApi } from \"../../OpenApi\";\nimport { OpenApiV3 } from \"../../OpenApiV3\";\nimport { OpenApiV3_1 } from \"../../OpenApiV3_1\";\nimport { IGeminiSchema } from \"../../structures/IGeminiSchema\";\nimport { ILlmFunction } from \"../../structures/ILlmFunction\";\nimport { ILlmSchemaV3 } from \"../../structures/ILlmSchemaV3\";\nimport { IOpenApiSchemaError } from \"../../structures/IOpenApiSchemaError\";\nimport { IResult } from \"../../typings/IResult\";\nimport { LlmTypeCheckerV3 } from \"../../utils/LlmTypeCheckerV3\";\nimport { OpenApiTypeChecker } from \"../../utils/OpenApiTypeChecker\";\nimport { LlmParametersFinder } from \"./LlmParametersComposer\";\nimport { LlmSchemaV3Composer } from \"./LlmSchemaV3Composer\";\n\nexport namespace GeminiSchemaComposer {\n  export const parameters = (props: {\n    config: IGeminiSchema.IConfig;\n    components: OpenApi.IComponents;\n    schema: OpenApi.IJsonSchema.IObject | OpenApi.IJsonSchema.IReference;\n    accessor?: string;\n    refAccessor?: string;\n  }): IResult<IGeminiSchema.IParameters, IOpenApiSchemaError> => {\n    const entity: IResult<OpenApi.IJsonSchema.IObject, IOpenApiSchemaError> =\n      LlmParametersFinder.parameters({\n        ...props,\n        method: \"GeminiSchemaComposer.parameters\",\n      });\n    if (entity.success === false) return entity;\n    return schema({\n      ...props,\n      schema: entity.value,\n    }) as IResult<IGeminiSchema.IParameters, IOpenApiSchemaError>;\n  };\n\n  export const schema = (props: {\n    config: IGeminiSchema.IConfig;\n    components: OpenApi.IComponents;\n    schema: OpenApi.IJsonSchema;\n    accessor?: string;\n    refAccessor?: string;\n  }): IResult<IGeminiSchema, IOpenApiSchemaError> => {\n    // TRANSFORM TO LLM SCHEMA OF V3.0\n    const result: IResult<ILlmSchemaV3, IOpenApiSchemaError> =\n      LlmSchemaV3Composer.schema({\n        ...props,\n        config: {\n          recursive: props.config.recursive,\n          constraint: false,\n        },\n        validate: (next, accessor): IOpenApiSchemaError.IReason[] => {\n          if (OpenApiTypeChecker.isObject(next)) {\n            if (!!next.additionalProperties)\n              return [\n                {\n                  schema: next,\n                  accessor: `${accessor}.additionalProperties`,\n                  message: \"Gemini does not allow additionalProperties.\",\n                },\n              ];\n          } else if (\n            OpenApiTypeChecker.isOneOf(next) &&\n            isOneOf(props.components)(next)\n          )\n            return [\n              {\n                schema: next,\n                accessor: accessor,\n                message: \"Gemini does not allow union type.\",\n              },\n            ];\n          return [];\n        },\n      });\n    if (result.success === false) return result;\n\n    // SPECIALIZATIONS\n    LlmTypeCheckerV3.visit({\n      schema: result.value,\n      closure: (v) => {\n        if (v.title !== undefined) {\n          if (v.description === undefined) v.description = v.title;\n          else {\n            const title: string = v.title.endsWith(\".\")\n              ? v.title.substring(0, v.title.length - 1)\n              : v.title;\n            v.description = v.description.startsWith(title)\n              ? v.description\n              : `${title}.\\n\\n${v.description}`;\n          }\n          delete v.title;\n        }\n        if (\n          LlmTypeCheckerV3.isObject(v) &&\n          v.additionalProperties !== undefined\n        ) {\n          delete (v as Partial<ILlmSchemaV3.IObject>).additionalProperties;\n        }\n      },\n    });\n\n    // DO NOT ALLOW UNION TYPE\n    return result;\n  };\n\n  export const separateParameters = (props: {\n    predicate: (schema: IGeminiSchema) => boolean;\n    parameters: IGeminiSchema.IParameters;\n  }): ILlmFunction.ISeparated<\"gemini\"> =>\n    LlmSchemaV3Composer.separateParameters(\n      props as {\n        predicate: (schema: ILlmSchemaV3) => boolean;\n        parameters: ILlmSchemaV3.IParameters;\n      },\n    ) as any as ILlmFunction.ISeparated<\"gemini\">;\n}\n\nconst isOneOf =\n  (components: OpenApi.IComponents) =>\n  (schema: OpenApi.IJsonSchema): boolean => {\n    const union: OpenApiV3_1.IJsonSchema[] = [];\n    const already: Set<string> = new Set();\n    const visit = (schema: OpenApi.IJsonSchema): void => {\n      if (\n        OpenApiTypeChecker.isBoolean(schema) ||\n        OpenApiTypeChecker.isInteger(schema) ||\n        OpenApiTypeChecker.isNumber(schema) ||\n        OpenApiTypeChecker.isString(schema)\n      )\n        union.push({ ...schema });\n      else if (\n        OpenApiTypeChecker.isArray(schema) ||\n        OpenApiTypeChecker.isTuple(schema) ||\n        OpenApiTypeChecker.isObject(schema)\n      )\n        union.push(schema);\n      else if (OpenApiTypeChecker.isOneOf(schema)) schema.oneOf.forEach(visit);\n      else if (OpenApiTypeChecker.isReference(schema)) {\n        if (already.has(schema.$ref)) union.push(schema);\n        else {\n          already.add(schema.$ref);\n          const target: OpenApi.IJsonSchema | undefined =\n            components.schemas?.[schema.$ref.split(\"/\").pop()!];\n          if (target === undefined) union.push(schema);\n          else visit(target);\n        }\n      }\n    };\n    const visitConstant = (schema: OpenApi.IJsonSchema): void => {\n      const insert = (value: any): void => {\n        const matched: OpenApiV3_1.IJsonSchema.INumber | undefined = union.find(\n          (u) =>\n            (u as OpenApiV3.IJsonSchema.__ISignificant<any>).type ===\n            typeof value,\n        ) as OpenApiV3.IJsonSchema.INumber | undefined;\n        if (matched !== undefined) {\n          matched.enum ??= [];\n          matched.enum.push(value);\n        } else union.push({ type: typeof value as \"number\", enum: [value] });\n      };\n      if (OpenApiTypeChecker.isConstant(schema)) insert(schema.const);\n      else if (OpenApiTypeChecker.isOneOf(schema))\n        for (const u of schema.oneOf)\n          if (OpenApiTypeChecker.isConstant(u)) insert(u.const);\n    };\n    visit(schema);\n    visitConstant(schema);\n    return union.length > 1;\n  };\n"],"names":["GeminiSchemaComposer","parameters","props","entity","LlmParametersFinder","method","success","schema","value","result","LlmSchemaV3Composer","config","recursive","constraint","validate","next","accessor","OpenApiTypeChecker","isObject","additionalProperties","message","isOneOf","components","LlmTypeCheckerV3","visit","closure","v","title","undefined","description","endsWith","substring","length","startsWith","separateParameters","union","already","Set","isBoolean","isInteger","isNumber","isString","push","isArray","isTuple","oneOf","forEach","isReference","has","$ref","add","target","schemas","split","pop","visitConstant","insert","matched","find","u","type","enum","isConstant","const"],"mappings":"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"}