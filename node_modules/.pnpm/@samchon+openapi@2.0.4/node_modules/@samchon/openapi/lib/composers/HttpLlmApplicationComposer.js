"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpLlmComposer = void 0;
var LlmSchemaComposer_1 = require("./LlmSchemaComposer");
var HttpLlmComposer;
(function (HttpLlmComposer) {
    HttpLlmComposer.application = function (props) {
        // COMPOSE FUNCTIONS
        var errors = props.migrate.errors
            .filter(function (e) { return e.operation()["x-samchon-human"] !== true; })
            .map(function (e) { return ({
            method: e.method,
            path: e.path,
            messages: e.messages,
            operation: function () { return e.operation(); },
            route: function () { return undefined; },
        }); });
        var functions = props.migrate.routes
            .filter(function (e) { return e.operation()["x-samchon-human"] !== true; })
            .map(function (route, i) {
            var _a, _b;
            if (route.method === "head") {
                errors.push({
                    method: route.method,
                    path: route.path,
                    messages: ["HEAD method is not supported in the LLM application."],
                    operation: function () { return route.operation(); },
                    route: function () { return route; },
                });
                return null;
            }
            else if (((_a = route.body) === null || _a === void 0 ? void 0 : _a.type) === "multipart/form-data" ||
                ((_b = route.success) === null || _b === void 0 ? void 0 : _b.type) === "multipart/form-data") {
                errors.push({
                    method: route.method,
                    path: route.path,
                    messages: [
                        "The \"multipart/form-data\" content type is not supported in the LLM application.",
                    ],
                    operation: function () { return route.operation(); },
                    route: function () { return route; },
                });
                return null;
            }
            var localErrors = [];
            var func = composeFunction({
                model: props.model,
                options: props.options,
                components: props.migrate.document().components,
                route: route,
                errors: localErrors,
                index: i,
            });
            if (func === null)
                errors.push({
                    method: route.method,
                    path: route.path,
                    messages: localErrors,
                    operation: function () { return route.operation(); },
                    route: function () { return route; },
                });
            return func;
        })
            .filter(function (v) { return v !== null; });
        return {
            model: props.model,
            options: props.options,
            functions: functions,
            errors: errors,
        };
    };
    var composeFunction = function (props) {
        var _a, _b, _c;
        var $defs = {};
        var cast = function (s, accessor) {
            var _a;
            var result = LlmSchemaComposer_1.LlmSchemaComposer.schema(props.model)({
                config: props.options,
                schema: s,
                components: props.components,
                $defs: $defs,
                accessor: accessor,
                refAccessor: "$input.components.schemas",
            });
            if (result.success === false) {
                (_a = props.errors).push.apply(_a, __spreadArray([], __read(result.error.reasons.map(function (r) { return "".concat(r.accessor, ": ").concat(r.message); })), false));
                return null;
            }
            return result.value;
        };
        var endpoint = "$input.paths[".concat(JSON.stringify(props.route.path), "][").concat(JSON.stringify(props.route.method), "]");
        var output = props.route
            .success
            ? cast(props.route.success.schema, "".concat(endpoint, ".responses[").concat(JSON.stringify(props.route.success.status), "][").concat(JSON.stringify(props.route.success.type), "].schema"))
            : undefined;
        var properties = __spreadArray(__spreadArray(__spreadArray([], __read(props.route.parameters.map(function (s) {
            var _a, _b;
            return [
                s.key,
                cast(__assign(__assign({}, s.schema), { title: (_a = s.parameter().title) !== null && _a !== void 0 ? _a : s.schema.title, description: (_b = s.parameter().description) !== null && _b !== void 0 ? _b : s.schema.description }), "".concat(endpoint, ".parameters[").concat(JSON.stringify(s.key), "].schema")),
            ];
        })), false), __read((props.route.query
            ? [
                [
                    props.route.query.key,
                    cast(__assign(__assign({}, props.route.query.schema), { title: (_a = props.route.query.title()) !== null && _a !== void 0 ? _a : props.route.query.schema.title, description: (_b = props.route.query.description()) !== null && _b !== void 0 ? _b : props.route.query.schema.description }), "".concat(endpoint, ".parameters[").concat(JSON.stringify(props.route.query.key), "].schema")),
                ],
            ]
            : [])), false), __read((props.route.body
            ? [
                [
                    props.route.body.key,
                    cast(__assign(__assign({}, props.route.body.schema), { description: (_c = props.route.body.description()) !== null && _c !== void 0 ? _c : props.route.body.schema.description }), "".concat(endpoint, ".requestBody.content[").concat(JSON.stringify(props.route.body.type), "].schema")),
                ],
            ]
            : [])), false);
        if (output === null || properties.some(function (_a) {
            var _b = __read(_a, 2), _k = _b[0], v = _b[1];
            return v === null;
        }))
            return null;
        // COMPOSE PARAMETERS
        var parameters = {
            type: "object",
            properties: Object.fromEntries(properties),
            additionalProperties: false,
            required: properties.map(function (_a) {
                var _b = __read(_a, 1), k = _b[0];
                return k;
            }),
        };
        if (Object.keys($defs).length)
            parameters.$defs = $defs;
        var operation = props.route.operation();
        // FINALIZATION
        return {
            method: props.route.method,
            path: props.route.path,
            name: props.route.accessor.join("_"),
            strict: true,
            parameters: parameters,
            separated: props.options.separate
                ? LlmSchemaComposer_1.LlmSchemaComposer.separateParameters(props.model)({
                    predicate: props.options.separate,
                    parameters: parameters,
                })
                : undefined,
            output: output,
            description: (function () {
                var _a, _b;
                if (!((_a = operation.summary) === null || _a === void 0 ? void 0 : _a.length) || !((_b = operation.description) === null || _b === void 0 ? void 0 : _b.length))
                    return operation.summary || operation.description;
                var summary = operation.summary.endsWith(".")
                    ? operation.summary.slice(0, -1)
                    : operation.summary;
                return operation.description.startsWith(summary)
                    ? operation.description
                    : summary + ".\n\n" + operation.description;
            })(),
            deprecated: operation.deprecated,
            tags: operation.tags,
            route: function () { return props.route; },
            operation: function () { return props.route.operation(); },
        };
    };
})(HttpLlmComposer || (exports.HttpLlmComposer = HttpLlmComposer = {}));
