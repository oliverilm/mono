{"version":3,"file":"OpenApiV3_1Emender.mjs","sources":["../../src/converters/OpenApiV3_1Emender.ts"],"sourcesContent":["import { OpenApi } from \"../OpenApi\";\nimport { OpenApiV3_1 } from \"../OpenApiV3_1\";\n\nexport namespace OpenApiV3_1Emender {\n  export const convert = (input: OpenApiV3_1.IDocument): OpenApi.IDocument => {\n    if ((input as OpenApi.IDocument)[\"x-samchon-emended\"] === true)\n      return input as OpenApi.IDocument;\n    return {\n      ...input,\n      components: convertComponents(input.components ?? {}),\n      paths: input.paths\n        ? Object.fromEntries(\n            Object.entries(input.paths)\n              .filter(([_, v]) => v !== undefined)\n              .map(\n                ([key, value]) => [key, convertPathItem(input)(value)] as const,\n              ),\n          )\n        : undefined,\n      webhooks: input.webhooks\n        ? Object.fromEntries(\n            Object.entries(input.webhooks)\n              .filter(([_, v]) => v !== undefined)\n              .map(\n                ([key, value]) =>\n                  [key, convertWebhooks(input)(value)!] as const,\n              )\n              .filter(([_, value]) => value !== undefined),\n          )\n        : undefined,\n      \"x-samchon-emended\": true,\n    };\n  };\n\n  /* -----------------------------------------------------------\n    OPERATORS\n  ----------------------------------------------------------- */\n  const convertWebhooks =\n    (doc: OpenApiV3_1.IDocument) =>\n    (\n      webhook:\n        | OpenApiV3_1.IPath\n        | OpenApiV3_1.IJsonSchema.IReference<`#/components/pathItems/${string}`>,\n    ): OpenApi.IPath | undefined => {\n      if (!TypeChecker.isReference(webhook))\n        return convertPathItem(doc)(webhook);\n      const found: OpenApiV3_1.IPath | undefined =\n        doc.components?.pathItems?.[webhook.$ref.split(\"/\").pop() ?? \"\"];\n      return found ? convertPathItem(doc)(found) : undefined;\n    };\n\n  const convertPathItem =\n    (doc: OpenApiV3_1.IDocument) =>\n    (pathItem: OpenApiV3_1.IPath): OpenApi.IPath => ({\n      ...(pathItem as any),\n      ...(pathItem.get\n        ? { get: convertOperation(doc)(pathItem)(pathItem.get) }\n        : undefined),\n      ...(pathItem.put\n        ? { put: convertOperation(doc)(pathItem)(pathItem.put) }\n        : undefined),\n      ...(pathItem.post\n        ? { post: convertOperation(doc)(pathItem)(pathItem.post) }\n        : undefined),\n      ...(pathItem.delete\n        ? { delete: convertOperation(doc)(pathItem)(pathItem.delete) }\n        : undefined),\n      ...(pathItem.options\n        ? { options: convertOperation(doc)(pathItem)(pathItem.options) }\n        : undefined),\n      ...(pathItem.head\n        ? { head: convertOperation(doc)(pathItem)(pathItem.head) }\n        : undefined),\n      ...(pathItem.patch\n        ? { patch: convertOperation(doc)(pathItem)(pathItem.patch) }\n        : undefined),\n      ...(pathItem.trace\n        ? { trace: convertOperation(doc)(pathItem)(pathItem.trace) }\n        : undefined),\n    });\n\n  const convertOperation =\n    (doc: OpenApiV3_1.IDocument) =>\n    (pathItem: OpenApiV3_1.IPath) =>\n    (input: OpenApiV3_1.IOperation): OpenApi.IOperation => ({\n      ...input,\n      parameters:\n        pathItem.parameters !== undefined || input.parameters !== undefined\n          ? [...(pathItem.parameters ?? []), ...(input.parameters ?? [])]\n              .map((p) => {\n                if (!TypeChecker.isReference(p))\n                  return convertParameter(doc.components ?? {})(p);\n                const found:\n                  | Omit<OpenApiV3_1.IOperation.IParameter, \"in\">\n                  | undefined = p.$ref.startsWith(\"#/components/headers/\")\n                  ? doc.components?.headers?.[p.$ref.split(\"/\").pop() ?? \"\"]\n                  : doc.components?.parameters?.[p.$ref.split(\"/\").pop() ?? \"\"];\n                return found !== undefined\n                  ? convertParameter(doc.components ?? {})({\n                      ...found,\n                      in: \"header\",\n                    })\n                  : undefined!;\n              })\n              .filter((_, v) => v !== undefined)\n          : undefined,\n      requestBody: input.requestBody\n        ? convertRequestBody(doc)(input.requestBody)\n        : undefined,\n      responses: input.responses\n        ? Object.fromEntries(\n            Object.entries(input.responses)\n              .filter(([_, v]) => v !== undefined)\n              .map(\n                ([key, value]) => [key, convertResponse(doc)(value)!] as const,\n              )\n              .filter(([_, value]) => value !== undefined),\n          )\n        : undefined,\n    });\n\n  const convertParameter =\n    (components: OpenApiV3_1.IComponents) =>\n    (\n      input: OpenApiV3_1.IOperation.IParameter,\n    ): OpenApi.IOperation.IParameter => ({\n      ...input,\n      schema: convertSchema(components)(input.schema),\n      examples: input.examples\n        ? Object.fromEntries(\n            Object.entries(input.examples)\n              .map(([key, value]) => [\n                key,\n                TypeChecker.isReference(value)\n                  ? components.examples?.[value.$ref.split(\"/\").pop() ?? \"\"]\n                  : value,\n              ])\n              .filter(([_, v]) => v !== undefined),\n          )\n        : undefined,\n    });\n\n  const convertRequestBody =\n    (doc: OpenApiV3_1.IDocument) =>\n    (\n      input:\n        | OpenApiV3_1.IOperation.IRequestBody\n        | OpenApiV3_1.IJsonSchema.IReference<`#/components/requestBodies/${string}`>,\n    ): OpenApi.IOperation.IRequestBody | undefined => {\n      if (TypeChecker.isReference(input)) {\n        const found: OpenApiV3_1.IOperation.IRequestBody | undefined =\n          doc.components?.requestBodies?.[input.$ref.split(\"/\").pop() ?? \"\"];\n        if (found === undefined) return undefined;\n        input = found;\n      }\n      return {\n        ...input,\n        content: input.content\n          ? convertContent(doc.components ?? {})(input.content)\n          : undefined,\n      };\n    };\n\n  const convertResponse =\n    (doc: OpenApiV3_1.IDocument) =>\n    (\n      input:\n        | OpenApiV3_1.IOperation.IResponse\n        | OpenApiV3_1.IJsonSchema.IReference<`#/components/responses/${string}`>,\n    ): OpenApi.IOperation.IResponse | undefined => {\n      if (TypeChecker.isReference(input)) {\n        const found: OpenApiV3_1.IOperation.IResponse | undefined =\n          doc.components?.responses?.[input.$ref.split(\"/\").pop() ?? \"\"];\n        if (found === undefined) return undefined;\n        input = found;\n      }\n      return {\n        ...input,\n        content: input.content\n          ? convertContent(doc.components ?? {})(input.content)\n          : undefined,\n        headers: input.headers\n          ? Object.fromEntries(\n              Object.entries(input.headers)\n                .filter(([_, v]) => v !== undefined)\n                .map(\n                  ([key, value]) =>\n                    [\n                      key,\n                      (() => {\n                        if (TypeChecker.isReference(value) === false)\n                          return convertParameter(doc.components ?? {})({\n                            ...value,\n                            in: \"header\",\n                          });\n                        const found:\n                          | Omit<OpenApiV3_1.IOperation.IParameter, \"in\">\n                          | undefined = value.$ref.startsWith(\n                          \"#/components/headers/\",\n                        )\n                          ? doc.components?.headers?.[\n                              value.$ref.split(\"/\").pop() ?? \"\"\n                            ]\n                          : undefined;\n                        return found !== undefined\n                          ? convertParameter(doc.components ?? {})({\n                              ...found,\n                              in: \"header\",\n                            })\n                          : undefined!;\n                      })(),\n                    ] as const,\n                )\n                .filter(([_, v]) => v !== undefined),\n            )\n          : undefined,\n      };\n    };\n\n  const convertContent =\n    (components: OpenApiV3_1.IComponents) =>\n    (\n      record: Record<string, OpenApiV3_1.IOperation.IMediaType>,\n    ): Record<string, OpenApi.IOperation.IMediaType> =>\n      Object.fromEntries(\n        Object.entries(record)\n          .filter(([_, v]) => v !== undefined)\n          .map(\n            ([key, value]) =>\n              [\n                key,\n                {\n                  ...value,\n                  schema: value.schema\n                    ? convertSchema(components)(value.schema)\n                    : undefined,\n                  examples: value.examples\n                    ? Object.fromEntries(\n                        Object.entries(value.examples)\n                          .map(([key, value]) => [\n                            key,\n                            TypeChecker.isReference(value)\n                              ? components.examples?.[\n                                  value.$ref.split(\"/\").pop() ?? \"\"\n                                ]\n                              : value,\n                          ])\n                          .filter(([_, v]) => v !== undefined),\n                      )\n                    : undefined,\n                },\n              ] as const,\n          ),\n      );\n\n  /* -----------------------------------------------------------\n    DEFINITIONS\n  ----------------------------------------------------------- */\n  const convertComponents = (\n    input: OpenApiV3_1.IComponents,\n  ): OpenApi.IComponents => ({\n    schemas: Object.fromEntries(\n      Object.entries(input.schemas ?? {})\n        .filter(([_, v]) => v !== undefined)\n        .map(([key, value]) => [key, convertSchema(input)(value)] as const),\n    ),\n    securitySchemes: input.securitySchemes,\n  });\n\n  const convertSchema =\n    (components: OpenApiV3_1.IComponents) =>\n    (input: OpenApiV3_1.IJsonSchema): OpenApi.IJsonSchema => {\n      const union: OpenApi.IJsonSchema[] = [];\n      const attribute: OpenApi.IJsonSchema.__IAttribute = {\n        title: input.title,\n        description: input.description,\n        ...Object.fromEntries(\n          Object.entries(input).filter(\n            ([key, value]) => key.startsWith(\"x-\") && value !== undefined,\n          ),\n        ),\n      };\n      const nullable: { value: boolean; default?: null } = {\n        value: false,\n        default: undefined,\n      };\n\n      const visit = (schema: OpenApiV3_1.IJsonSchema): void => {\n        // NULLABLE PROPERTY\n        if (\n          (schema as OpenApiV3_1.IJsonSchema.__ISignificant<any>).nullable ===\n          true\n        ) {\n          nullable.value ||= true;\n          if ((schema as OpenApiV3_1.IJsonSchema.INumber).default === null)\n            nullable.default = null;\n        }\n        if (\n          Array.isArray((schema as OpenApiV3_1.IJsonSchema.INumber).enum) &&\n          (schema as OpenApiV3_1.IJsonSchema.INumber).enum?.length &&\n          (schema as OpenApiV3_1.IJsonSchema.INumber).enum?.some(\n            (e) => e === null,\n          )\n        )\n          nullable.value ||= true;\n\n        // MIXED TYPE CASE\n        if (TypeChecker.isMixed(schema)) {\n          if (schema.const !== undefined)\n            visit({\n              ...schema,\n              ...{\n                type: undefined,\n                oneOf: undefined,\n                anyOf: undefined,\n                allOf: undefined,\n                $ref: undefined,\n              },\n            });\n          if (schema.oneOf !== undefined)\n            visit({\n              ...schema,\n              ...{\n                type: undefined,\n                anyOf: undefined,\n                allOf: undefined,\n                $ref: undefined,\n              },\n            });\n          if (schema.anyOf !== undefined)\n            visit({\n              ...schema,\n              ...{\n                type: undefined,\n                oneOf: undefined,\n                allOf: undefined,\n                $ref: undefined,\n              },\n            });\n          if (schema.allOf !== undefined)\n            visit({\n              ...schema,\n              ...{\n                type: undefined,\n                oneOf: undefined,\n                anyOf: undefined,\n                $ref: undefined,\n              },\n            });\n          for (const type of schema.type)\n            if (type === \"boolean\" || type === \"number\" || type === \"string\")\n              visit({\n                ...schema,\n                ...{\n                  enum:\n                    schema.enum?.length && schema.enum.filter((e) => e !== null)\n                      ? schema.enum.filter((x) => typeof x === type)\n                      : undefined,\n                },\n                type: type as any,\n              });\n            else if (type === \"integer\")\n              visit({\n                ...schema,\n                ...{\n                  enum:\n                    schema.enum?.length && schema.enum.filter((e) => e !== null)\n                      ? schema.enum.filter(\n                          (x) =>\n                            x !== null &&\n                            typeof x === \"number\" &&\n                            Number.isInteger(x),\n                        )\n                      : undefined,\n                },\n                type: type as any,\n              });\n            else visit({ ...schema, type: type as any });\n        }\n        // UNION TYPE CASE\n        else if (TypeChecker.isOneOf(schema)) schema.oneOf.forEach(visit);\n        else if (TypeChecker.isAnyOf(schema)) schema.anyOf.forEach(visit);\n        else if (TypeChecker.isAllOf(schema))\n          if (schema.allOf.length === 1) visit(schema.allOf[0]);\n          else union.push(convertAllOfSchema(components)(schema));\n        // ATOMIC TYPE CASE (CONSIDER ENUM VALUES)\n        else if (TypeChecker.isBoolean(schema))\n          if (\n            schema.enum?.length &&\n            schema.enum.filter((e) => e !== null).length\n          )\n            for (const value of schema.enum.filter((e) => e !== null))\n              union.push({\n                const: value,\n                ...({\n                  ...schema,\n                  type: undefined as any,\n                  enum: undefined,\n                  default: undefined,\n                } satisfies OpenApiV3_1.IJsonSchema.IBoolean as any),\n              } satisfies OpenApi.IJsonSchema.IConstant);\n          else\n            union.push({\n              ...schema,\n              default: schema.default ?? undefined,\n              ...{\n                enum: undefined,\n              },\n            });\n        else if (TypeChecker.isInteger(schema) || TypeChecker.isNumber(schema))\n          if (schema.enum?.length && schema.enum.filter((e) => e !== null))\n            for (const value of schema.enum.filter((e) => e !== null))\n              union.push({\n                const: value,\n                ...({\n                  ...schema,\n                  type: undefined as any,\n                  enum: undefined,\n                  default: undefined,\n                  minimum: undefined,\n                  maximum: undefined,\n                  exclusiveMinimum: undefined,\n                  exclusiveMaximum: undefined,\n                  multipleOf: undefined,\n                } satisfies OpenApiV3_1.IJsonSchema.IInteger as any),\n              } satisfies OpenApi.IJsonSchema.IConstant);\n          else\n            union.push({\n              ...schema,\n              default: schema.default ?? undefined,\n              ...{\n                enum: undefined,\n              },\n              ...(typeof schema.exclusiveMinimum === \"number\"\n                ? {\n                    minimum: schema.exclusiveMinimum,\n                    exclusiveMinimum: true,\n                  }\n                : {\n                    exclusiveMinimum: schema.exclusiveMinimum,\n                  }),\n              ...(typeof schema.exclusiveMaximum === \"number\"\n                ? {\n                    maximum: schema.exclusiveMaximum,\n                    exclusiveMaximum: true,\n                  }\n                : {\n                    exclusiveMaximum: schema.exclusiveMaximum,\n                  }),\n            });\n        else if (TypeChecker.isString(schema))\n          if (\n            schema.enum?.length &&\n            schema.enum.filter((e) => e !== null).length\n          )\n            for (const value of schema.enum.filter((e) => e !== null))\n              union.push({\n                const: value,\n                ...({\n                  ...schema,\n                  type: undefined as any,\n                  enum: undefined,\n                  default: undefined,\n                } satisfies OpenApiV3_1.IJsonSchema.IString as any),\n              } satisfies OpenApi.IJsonSchema.IConstant);\n          else\n            union.push({\n              ...schema,\n              default: schema.default ?? undefined,\n              ...{\n                enum: undefined,\n              },\n            });\n        // ARRAY TYPE CASE (CONSIDER TUPLE)\n        else if (TypeChecker.isArray(schema)) {\n          if (Array.isArray(schema.items))\n            union.push({\n              ...schema,\n              ...{\n                items: undefined!,\n                prefixItems: schema.items.map(convertSchema(components)),\n                additionalItems:\n                  typeof schema.additionalItems === \"object\" &&\n                  schema.additionalItems !== null\n                    ? convertSchema(components)(schema.additionalItems)\n                    : schema.additionalItems,\n              },\n            } satisfies OpenApi.IJsonSchema.ITuple);\n          else if (Array.isArray(schema.prefixItems))\n            union.push({\n              ...schema,\n              ...{\n                items: undefined!,\n                prefixItems: schema.prefixItems.map(convertSchema(components)),\n                additionalItems:\n                  typeof schema.additionalItems === \"object\" &&\n                  schema.additionalItems !== null\n                    ? convertSchema(components)(schema.additionalItems)\n                    : schema.additionalItems,\n              },\n            });\n          else if (schema.items === undefined)\n            union.push({\n              ...schema,\n              ...{\n                items: undefined!,\n                prefixItems: [],\n              },\n            });\n          else\n            union.push({\n              ...schema,\n              ...{\n                items: convertSchema(components)(schema.items),\n                prefixItems: undefined,\n                additionalItems: undefined,\n              },\n            });\n        }\n        // OBJECT TYPE CASE\n        else if (TypeChecker.isObject(schema))\n          union.push({\n            ...schema,\n            ...{\n              properties: schema.properties\n                ? Object.fromEntries(\n                    Object.entries(schema.properties)\n                      .filter(([_, v]) => v !== undefined)\n                      .map(\n                        ([key, value]) =>\n                          [key, convertSchema(components)(value)] as const,\n                      ),\n                  )\n                : {},\n              additionalProperties: schema.additionalProperties\n                ? typeof schema.additionalProperties === \"object\" &&\n                  schema.additionalProperties !== null\n                  ? convertSchema(components)(schema.additionalProperties)\n                  : schema.additionalProperties\n                : undefined,\n              required: schema.required ?? [],\n            },\n          });\n        else if (TypeChecker.isRecursiveReference(schema))\n          union.push({\n            ...schema,\n            ...{\n              $ref: schema.$recursiveRef,\n              $recursiveRef: undefined,\n            },\n          });\n        // THE OTHERS\n        else union.push(schema);\n      };\n\n      visit(input);\n      if (\n        nullable.value === true &&\n        !union.some((e) => (e as OpenApi.IJsonSchema.INull).type === \"null\")\n      )\n        union.push({\n          type: \"null\",\n          default: nullable.default,\n        });\n      return {\n        ...(union.length === 0\n          ? { type: undefined }\n          : union.length === 1\n            ? { ...union[0] }\n            : { oneOf: union.map((u) => ({ ...u, nullable: undefined })) }),\n        ...attribute,\n        ...{ nullable: undefined },\n      };\n    };\n\n  const convertAllOfSchema =\n    (components: OpenApiV3_1.IComponents) =>\n    (input: OpenApiV3_1.IJsonSchema.IAllOf): OpenApi.IJsonSchema => {\n      const objects: Array<OpenApiV3_1.IJsonSchema.IObject | null> =\n        input.allOf.map((schema) => retrieveObject(components)(schema));\n      if (objects.some((obj) => obj === null))\n        return {\n          type: undefined,\n          ...{\n            allOf: undefined,\n          },\n        };\n      return {\n        ...input,\n        type: \"object\",\n        properties: Object.fromEntries(\n          objects\n            .map((o) => Object.entries(o?.properties ?? {}))\n            .flat()\n            .map(\n              ([key, value]) =>\n                [key, convertSchema(components)(value)] as const,\n            ),\n        ),\n        ...{\n          allOf: undefined,\n          required: [...new Set(objects.map((o) => o?.required ?? []).flat())],\n        },\n      };\n    };\n\n  const retrieveObject =\n    (components: OpenApiV3_1.IComponents) =>\n    (\n      input: OpenApiV3_1.IJsonSchema,\n      visited: Set<OpenApiV3_1.IJsonSchema> = new Set(),\n    ): OpenApiV3_1.IJsonSchema.IObject | null => {\n      if (TypeChecker.isObject(input))\n        return input.properties !== undefined && !input.additionalProperties\n          ? input\n          : null;\n      else if (visited.has(input)) return null;\n      else visited.add(input);\n\n      if (TypeChecker.isReference(input))\n        return retrieveObject(components)(\n          components.schemas?.[input.$ref.split(\"/\").pop() ?? \"\"] ?? {},\n          visited,\n        );\n      else if (TypeChecker.isRecursiveReference(input))\n        return retrieveObject(components)(\n          components.schemas?.[input.$recursiveRef.split(\"/\").pop() ?? \"\"] ??\n            {},\n          visited,\n        );\n      return null;\n    };\n\n  namespace TypeChecker {\n    export const isConstant = (\n      schema: OpenApiV3_1.IJsonSchema,\n    ): schema is OpenApiV3_1.IJsonSchema.IConstant =>\n      (schema as OpenApiV3_1.IJsonSchema.IConstant).const !== undefined;\n    export const isBoolean = (\n      schema: OpenApiV3_1.IJsonSchema,\n    ): schema is OpenApiV3_1.IJsonSchema.IBoolean =>\n      (schema as OpenApiV3_1.IJsonSchema.IBoolean).type === \"boolean\";\n    export const isInteger = (\n      schema: OpenApiV3_1.IJsonSchema,\n    ): schema is OpenApiV3_1.IJsonSchema.IInteger =>\n      (schema as OpenApiV3_1.IJsonSchema.IInteger).type === \"integer\";\n    export const isNumber = (\n      schema: OpenApiV3_1.IJsonSchema,\n    ): schema is OpenApiV3_1.IJsonSchema.INumber =>\n      (schema as OpenApiV3_1.IJsonSchema.INumber).type === \"number\";\n    export const isString = (\n      schema: OpenApiV3_1.IJsonSchema,\n    ): schema is OpenApiV3_1.IJsonSchema.IString =>\n      (schema as OpenApiV3_1.IJsonSchema.IString).type === \"string\";\n    export const isArray = (\n      schema: OpenApiV3_1.IJsonSchema,\n    ): schema is OpenApiV3_1.IJsonSchema.IArray =>\n      (schema as OpenApiV3_1.IJsonSchema.IArray).type === \"array\";\n    export const isObject = (\n      schema: OpenApiV3_1.IJsonSchema,\n    ): schema is OpenApiV3_1.IJsonSchema.IObject =>\n      (schema as OpenApiV3_1.IJsonSchema.IObject).type === \"object\";\n    export const isReference = (\n      schema: OpenApiV3_1.IJsonSchema,\n    ): schema is OpenApiV3_1.IJsonSchema.IReference =>\n      (schema as OpenApiV3_1.IJsonSchema.IReference).$ref !== undefined;\n    export const isRecursiveReference = (\n      schema: OpenApiV3_1.IJsonSchema,\n    ): schema is OpenApiV3_1.IJsonSchema.IRecursiveReference =>\n      (schema as OpenApiV3_1.IJsonSchema.IRecursiveReference).$recursiveRef !==\n      undefined;\n    export const isAllOf = (\n      schema: OpenApiV3_1.IJsonSchema,\n    ): schema is OpenApiV3_1.IJsonSchema.IAllOf =>\n      (schema as OpenApiV3_1.IJsonSchema.IAllOf).allOf !== undefined;\n    export const isAnyOf = (\n      schema: OpenApiV3_1.IJsonSchema,\n    ): schema is OpenApiV3_1.IJsonSchema.IAnyOf =>\n      (schema as OpenApiV3_1.IJsonSchema.IAnyOf).anyOf !== undefined;\n    export const isOneOf = (\n      schema: OpenApiV3_1.IJsonSchema,\n    ): schema is OpenApiV3_1.IJsonSchema.IOneOf =>\n      (schema as OpenApiV3_1.IJsonSchema.IOneOf).oneOf !== undefined;\n    export const isNullOnly = (\n      schema: OpenApiV3_1.IJsonSchema,\n    ): schema is OpenApiV3_1.IJsonSchema.INull =>\n      (schema as OpenApiV3_1.IJsonSchema.INull).type === \"null\";\n    export const isMixed = (\n      schema: OpenApiV3_1.IJsonSchema,\n    ): schema is OpenApiV3_1.IJsonSchema.IMixed =>\n      Array.isArray((schema as OpenApiV3_1.IJsonSchema.IMixed).type);\n  }\n}\n"],"names":["OpenApiV3_1Emender","convert","input","components","convertComponents","paths","Object","fromEntries","entries","filter","_","v","undefined","map","key","value","convertPathItem","webhooks","convertWebhooks","doc","webhook","TypeChecker","isReference","found","pathItems","$ref","split","pop","pathItem","get","convertOperation","put","post","delete","options","head","patch","trace","parameters","p","convertParameter","startsWith","headers","in","requestBody","convertRequestBody","responses","convertResponse","schema","convertSchema","examples","requestBodies","content","convertContent","record","schemas","securitySchemes","union","attribute","title","description","nullable","default","visit","Array","isArray","enum","length","some","e","isMixed","const","type","oneOf","anyOf","allOf","x","Number","isInteger","isOneOf","forEach","isAnyOf","isAllOf","push","convertAllOfSchema","isBoolean","isNumber","minimum","maximum","exclusiveMinimum","exclusiveMaximum","multipleOf","isString","items","prefixItems","additionalItems","isObject","properties","additionalProperties","required","isRecursiveReference","$recursiveRef","u","objects","retrieveObject","obj","o","flat","Set","visited","has","add","isConstant","isNullOnly"],"mappings":"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"}