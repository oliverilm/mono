"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenApiTypeCheckerBase = void 0;
var AccessorUtil_1 = require("../AccessorUtil");
var MapUtil_1 = require("../MapUtil");
var JsonDescriptionUtil_1 = require("./JsonDescriptionUtil");
/**
 * @internal
 */
var OpenApiTypeCheckerBase;
(function (OpenApiTypeCheckerBase) {
    /* -----------------------------------------------------------
      TYPE CHECKERS
    ----------------------------------------------------------- */
    OpenApiTypeCheckerBase.isNull = function (schema) {
        return schema.type === "null";
    };
    OpenApiTypeCheckerBase.isUnknown = function (schema) {
        return schema.type === undefined &&
            !OpenApiTypeCheckerBase.isConstant(schema) &&
            !OpenApiTypeCheckerBase.isOneOf(schema) &&
            !OpenApiTypeCheckerBase.isReference(schema);
    };
    OpenApiTypeCheckerBase.isConstant = function (schema) {
        return schema.const !== undefined;
    };
    OpenApiTypeCheckerBase.isBoolean = function (schema) {
        return schema.type === "boolean";
    };
    OpenApiTypeCheckerBase.isInteger = function (schema) {
        return schema.type === "integer";
    };
    OpenApiTypeCheckerBase.isNumber = function (schema) {
        return schema.type === "number";
    };
    OpenApiTypeCheckerBase.isString = function (schema) {
        return schema.type === "string";
    };
    OpenApiTypeCheckerBase.isArray = function (schema) {
        return schema.type === "array" &&
            schema.items !== undefined;
    };
    OpenApiTypeCheckerBase.isTuple = function (schema) {
        return schema.type === "array" &&
            schema.prefixItems !== undefined;
    };
    OpenApiTypeCheckerBase.isObject = function (schema) {
        return schema.type === "object";
    };
    OpenApiTypeCheckerBase.isReference = function (schema) {
        return schema.$ref !== undefined;
    };
    OpenApiTypeCheckerBase.isOneOf = function (schema) {
        return schema.oneOf !== undefined;
    };
    OpenApiTypeCheckerBase.isRecursiveReference = function (props) {
        if (OpenApiTypeCheckerBase.isReference(props.schema) === false)
            return false;
        var current = props.schema.$ref.split(props.prefix)[1];
        var counter = 0;
        OpenApiTypeCheckerBase.visit({
            prefix: props.prefix,
            components: props.components,
            schema: props.schema,
            closure: function (schema) {
                if (OpenApiTypeCheckerBase.isReference(schema)) {
                    var next = schema.$ref.split(props.prefix)[1];
                    if (current === next)
                        ++counter;
                }
            },
        });
        return counter > 1;
    };
    /* -----------------------------------------------------------
      OPERATORS
    ----------------------------------------------------------- */
    OpenApiTypeCheckerBase.unreference = function (props) {
        var _a, _b;
        var reasons = [];
        var result = unreferenceSchema({
            prefix: props.prefix,
            refAccessor: (_a = props.refAccessor) !== null && _a !== void 0 ? _a : "$input.".concat(props.prefix
                .substring(2)
                .split("/")
                .filter(function (s) { return !!s.length; })
                .join(".")),
            accessor: (_b = props.accessor) !== null && _b !== void 0 ? _b : "$input.schema",
            components: props.components,
            schema: props.schema,
            reasons: reasons,
        });
        if (result === null)
            return {
                success: false,
                error: {
                    method: props.method,
                    message: "failed to unreference due to unable to find.",
                    reasons: reasons,
                },
            };
        return {
            success: true,
            value: result,
        };
    };
    OpenApiTypeCheckerBase.escape = function (props) {
        var _a, _b;
        var reasons = [];
        var result = escapeSchema(__assign(__assign({}, props), { reasons: reasons, visited: new Map(), accessor: (_a = props.accessor) !== null && _a !== void 0 ? _a : "$input.schema", refAccessor: (_b = props.refAccessor) !== null && _b !== void 0 ? _b : AccessorUtil_1.AccessorUtil.reference(props.prefix) })) || null;
        if (result === null)
            return {
                success: false,
                error: {
                    method: props.method,
                    message: "failed to escape some reference type(s) due to unable to find".concat(Number(props.recursive) === 0 ? " or recursive relationship" : "", "."),
                    reasons: reasons,
                },
            };
        return {
            success: true,
            value: result,
        };
    };
    OpenApiTypeCheckerBase.visit = function (props) {
        var _a, _b;
        var already = new Set();
        var refAccessor = (_a = props.refAccessor) !== null && _a !== void 0 ? _a : "$input.".concat(AccessorUtil_1.AccessorUtil.reference(props.prefix));
        var next = function (schema, accessor) {
            var e_1, _a;
            var _b, _c, _d;
            props.closure(schema, accessor);
            if (OpenApiTypeCheckerBase.isReference(schema)) {
                var key = schema.$ref.split(props.prefix).pop();
                if (already.has(key) === true)
                    return;
                already.add(key);
                var found = (_b = props.components.schemas) === null || _b === void 0 ? void 0 : _b[key];
                if (found !== undefined)
                    next(found, "".concat(refAccessor, "[").concat(JSON.stringify(key), "]"));
            }
            else if (OpenApiTypeCheckerBase.isOneOf(schema))
                schema.oneOf.forEach(function (s, i) { return next(s, "".concat(accessor, ".oneOf[").concat(i, "]")); });
            else if (OpenApiTypeCheckerBase.isObject(schema)) {
                try {
                    for (var _e = __values(Object.entries((_c = schema.properties) !== null && _c !== void 0 ? _c : {})), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var _g = __read(_f.value, 2), key = _g[0], value = _g[1];
                        next(value, "".concat(accessor, ".properties[").concat(JSON.stringify(key), "]"));
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                if (typeof schema.additionalProperties === "object" &&
                    schema.additionalProperties !== null)
                    next(schema.additionalProperties, "".concat(accessor, ".additionalProperties"));
            }
            else if (OpenApiTypeCheckerBase.isArray(schema))
                next(schema.items, "".concat(accessor, ".items"));
            else if (OpenApiTypeCheckerBase.isTuple(schema)) {
                ((_d = schema.prefixItems) !== null && _d !== void 0 ? _d : []).forEach(function (s, i) {
                    return next(s, "".concat(accessor, ".prefixItems[").concat(i, "]"));
                });
                if (typeof schema.additionalItems === "object" &&
                    schema.additionalItems !== null)
                    next(schema.additionalItems, "".concat(accessor, ".additionalItems"));
            }
        };
        next(props.schema, (_b = props.accessor) !== null && _b !== void 0 ? _b : "$input.schema");
    };
    OpenApiTypeCheckerBase.covers = function (props) {
        return coverStation({
            prefix: props.prefix,
            components: props.components,
            x: props.x,
            y: props.y,
            visited: new Map(),
        });
    };
    var unreferenceSchema = function (props) {
        var _a;
        if (OpenApiTypeCheckerBase.isReference(props.schema) === false)
            return props.schema;
        var key = props.schema.$ref.split(props.prefix).pop();
        var found = (_a = props.components.schemas) === null || _a === void 0 ? void 0 : _a[key];
        if (found === undefined) {
            props.reasons.push({
                schema: props.schema,
                accessor: props.accessor,
                message: "unable to find reference type ".concat(JSON.stringify(key), "."),
            });
            return null;
        }
        else if (OpenApiTypeCheckerBase.isReference(found) === false)
            return found;
        else if (props.first === key) {
            props.reasons.push({
                schema: props.schema,
                accessor: props.accessor,
                message: "recursive reference type ".concat(JSON.stringify(key), "."),
            });
            return null;
        }
        return unreferenceSchema(__assign(__assign({}, props), { accessor: "".concat(props.refAccessor, "[").concat(JSON.stringify(key), "]"), first: key }));
    };
    var escapeSchema = function (props) {
        var _a, _b, _c, _d;
        if (OpenApiTypeCheckerBase.isReference(props.schema)) {
            // REFERENCE
            var key = props.schema.$ref.split(props.prefix)[1];
            var target = (_a = props.components.schemas) === null || _a === void 0 ? void 0 : _a[key];
            if (target === undefined) {
                props.reasons.push({
                    schema: props.schema,
                    accessor: props.accessor,
                    message: "unable to find reference type ".concat(JSON.stringify(key), "."),
                });
                return null;
            }
            else if (props.visited.has(key) === true) {
                if (props.recursive === false)
                    return null;
                var depth = props.visited.get(key);
                if (depth > props.recursive) {
                    if (props.recursive === 0) {
                        props.reasons.push({
                            schema: props.schema,
                            accessor: props.accessor,
                            message: "recursive reference type ".concat(JSON.stringify(key), "."),
                        });
                        return null;
                    }
                    return undefined;
                }
                props.visited.set(key, depth + 1);
                var res = escapeSchema(__assign(__assign({}, props), { schema: target, accessor: "".concat(props.refAccessor, "[").concat(JSON.stringify(key), "]") }));
                return res
                    ? __assign(__assign({}, res), { description: JsonDescriptionUtil_1.JsonDescriptionUtil.cascade({
                            prefix: props.prefix,
                            components: props.components,
                            $ref: props.schema.$ref,
                            description: res.description,
                            escape: true,
                        }) }) : res;
            }
            else {
                var res = escapeSchema(__assign(__assign({}, props), { schema: target, accessor: "".concat(props.refAccessor, "[").concat(JSON.stringify(key), "]"), visited: new Map(__spreadArray(__spreadArray([], __read(props.visited), false), [[key, 1]], false)) }));
                return res
                    ? __assign(__assign({}, res), { description: JsonDescriptionUtil_1.JsonDescriptionUtil.cascade({
                            prefix: props.prefix,
                            components: props.components,
                            $ref: props.schema.$ref,
                            description: res.description,
                            escape: true,
                        }) }) : res;
            }
        }
        else if (OpenApiTypeCheckerBase.isOneOf(props.schema)) {
            // UNION
            var elements = props.schema.oneOf.map(function (s, i) {
                return escapeSchema(__assign(__assign({}, props), { schema: s, accessor: "".concat(props.accessor, ".oneOf[").concat(i, "]") }));
            });
            if (elements.some(function (v) { return v === null; }))
                return null;
            var filtered = elements.filter(function (v) { return v !== undefined; });
            if (filtered.length === 0)
                return undefined;
            return __assign(__assign({}, props), { oneOf: filtered
                    .map(function (v) {
                    return flatSchema({
                        prefix: props.prefix,
                        components: props.components,
                        schema: v,
                    });
                })
                    .flat() });
        }
        else if (OpenApiTypeCheckerBase.isObject(props.schema)) {
            // OBJECT
            var object_1 = props.schema;
            var properties_1 = Object.entries((_b = object_1.properties) !== null && _b !== void 0 ? _b : {}).map(function (_a) {
                var _b = __read(_a, 2), k = _b[0], s = _b[1];
                return [
                    k,
                    escapeSchema(__assign(__assign({}, props), { schema: s, visited: props.visited, accessor: "".concat(props.accessor, ".properties[").concat(JSON.stringify(k), "]") })),
                ];
            });
            var additionalProperties = object_1.additionalProperties
                ? typeof object_1.additionalProperties === "object" &&
                    object_1.additionalProperties !== null
                    ? escapeSchema(__assign(__assign({}, props), { schema: object_1.additionalProperties, accessor: "".concat(props.accessor, ".additionalProperties") }))
                    : object_1.additionalProperties
                : false;
            if (properties_1.some(function (_a) {
                var _b = __read(_a, 2), _k = _b[0], v = _b[1];
                return v === null;
            }) ||
                additionalProperties === null)
                return null;
            else if (properties_1.some(function (_a) {
                var _b;
                var _c = __read(_a, 2), k = _c[0], v = _c[1];
                return v === undefined && ((_b = object_1.required) === null || _b === void 0 ? void 0 : _b.includes(k)) === true;
            }) === true)
                return undefined;
            return __assign(__assign({}, object_1), { properties: Object.fromEntries(properties_1.filter(function (_a) {
                    var _b = __read(_a, 2), _k = _b[0], v = _b[1];
                    return v !== undefined;
                })), additionalProperties: additionalProperties !== null && additionalProperties !== void 0 ? additionalProperties : false, required: (_d = (_c = object_1.required) === null || _c === void 0 ? void 0 : _c.filter(function (k) {
                    return properties_1.some(function (_a) {
                        var _b = __read(_a, 2), key = _b[0], value = _b[1];
                        return key === k && value !== undefined;
                    });
                })) !== null && _d !== void 0 ? _d : [] });
        }
        else if (OpenApiTypeCheckerBase.isTuple(props.schema)) {
            // TUPLE
            var elements = props.schema.prefixItems.map(function (s, i) {
                return escapeSchema(__assign(__assign({}, props), { schema: s, accessor: "".concat(props.accessor, ".prefixItems[").concat(i, "]") }));
            });
            var additionalItems = props.schema.additionalItems
                ? typeof props.schema.additionalItems === "object" &&
                    props.schema.additionalItems !== null
                    ? escapeSchema(__assign(__assign({}, props), { schema: props.schema.additionalItems, accessor: "".concat(props.accessor, ".additionalItems") }))
                    : props.schema.additionalItems
                : false;
            if (elements.some(function (v) { return v === null; }) || additionalItems === null)
                return null;
            else if (elements.some(function (v) { return v === undefined; }))
                return undefined;
            return __assign(__assign({}, props.schema), { prefixItems: elements, additionalItems: additionalItems !== null && additionalItems !== void 0 ? additionalItems : false });
        }
        else if (OpenApiTypeCheckerBase.isArray(props.schema)) {
            // ARRAY
            var items = escapeSchema(__assign(__assign({}, props), { schema: props.schema.items, accessor: "".concat(props.accessor, ".items") }));
            if (items === null)
                return null;
            else if (items === undefined)
                return __assign(__assign({}, props.schema), { minItems: undefined, maxItems: 0, items: {} });
            return __assign(__assign({}, props.schema), { items: items });
        }
        return props.schema;
    };
    var coverStation = function (p) {
        var _a;
        var cache = (_a = p.visited.get(p.x)) === null || _a === void 0 ? void 0 : _a.get(p.y);
        if (cache !== undefined)
            return cache;
        // FOR RECURSIVE CASE
        var nested = MapUtil_1.MapUtil.take(p.visited)(p.x)(function () { return new Map(); });
        nested.set(p.y, true);
        // COMPUTE IT
        var result = coverSchema(p);
        nested.set(p.y, result);
        return result;
    };
    var coverSchema = function (p) {
        // CHECK EQUALITY
        if (p.x === p.y)
            return true;
        else if (OpenApiTypeCheckerBase.isReference(p.x) && OpenApiTypeCheckerBase.isReference(p.y) && p.x.$ref === p.y.$ref)
            return true;
        // COMPARE WITH FLATTENING
        var alpha = flatSchema({
            prefix: p.prefix,
            components: p.components,
            schema: p.x,
        });
        var beta = flatSchema({
            prefix: p.prefix,
            components: p.components,
            schema: p.y,
        });
        if (alpha.some(function (x) { return OpenApiTypeCheckerBase.isUnknown(x); }))
            return true;
        else if (beta.some(function (x) { return OpenApiTypeCheckerBase.isUnknown(x); }))
            return false;
        return beta.every(function (b) {
            return alpha.some(function (a) {
                return coverEscapedSchema({
                    prefix: p.prefix,
                    components: p.components,
                    visited: p.visited,
                    x: a,
                    y: b,
                });
            });
        });
    };
    var coverEscapedSchema = function (p) {
        // CHECK EQUALITY
        if (p.x === p.y)
            return true;
        else if (OpenApiTypeCheckerBase.isUnknown(p.x))
            return true;
        else if (OpenApiTypeCheckerBase.isUnknown(p.y))
            return false;
        else if (OpenApiTypeCheckerBase.isNull(p.x))
            return OpenApiTypeCheckerBase.isNull(p.y);
        // ATOMIC CASE
        else if (OpenApiTypeCheckerBase.isConstant(p.x))
            return OpenApiTypeCheckerBase.isConstant(p.y) && p.x.const === p.y.const;
        else if (OpenApiTypeCheckerBase.isBoolean(p.x))
            return (OpenApiTypeCheckerBase.isBoolean(p.y) || (OpenApiTypeCheckerBase.isConstant(p.y) && typeof p.y.const === "boolean"));
        else if (OpenApiTypeCheckerBase.isInteger(p.x))
            return (OpenApiTypeCheckerBase.isInteger(p.y) || OpenApiTypeCheckerBase.isConstant(p.y)) && coverInteger(p.x, p.y);
        else if (OpenApiTypeCheckerBase.isNumber(p.x))
            return ((OpenApiTypeCheckerBase.isConstant(p.y) || OpenApiTypeCheckerBase.isInteger(p.y) || OpenApiTypeCheckerBase.isNumber(p.y)) &&
                coverNumber(p.x, p.y));
        else if (OpenApiTypeCheckerBase.isString(p.x))
            return (OpenApiTypeCheckerBase.isConstant(p.y) || OpenApiTypeCheckerBase.isString(p.y)) && coverString(p.x, p.y);
        // INSTANCE CASE
        else if (OpenApiTypeCheckerBase.isArray(p.x))
            return ((OpenApiTypeCheckerBase.isArray(p.y) || OpenApiTypeCheckerBase.isTuple(p.y)) &&
                coverArray({
                    prefix: p.prefix,
                    components: p.components,
                    visited: p.visited,
                    x: p.x,
                    y: p.y,
                }));
        else if (OpenApiTypeCheckerBase.isObject(p.x))
            return (OpenApiTypeCheckerBase.isObject(p.y) &&
                coverObject({
                    prefix: p.prefix,
                    components: p.components,
                    visited: p.visited,
                    x: p.x,
                    y: p.y,
                }));
        else if (OpenApiTypeCheckerBase.isReference(p.x))
            return OpenApiTypeCheckerBase.isReference(p.y) && p.x.$ref === p.y.$ref;
        return false;
    };
    var coverArray = function (p) {
        if (OpenApiTypeCheckerBase.isTuple(p.y))
            return (p.y.prefixItems.every(function (v) {
                return coverStation({
                    prefix: p.prefix,
                    components: p.components,
                    visited: p.visited,
                    x: p.x.items,
                    y: v,
                });
            }) &&
                (p.y.additionalItems === undefined ||
                    (typeof p.y.additionalItems === "object" &&
                        coverStation({
                            prefix: p.prefix,
                            components: p.components,
                            visited: p.visited,
                            x: p.x.items,
                            y: p.y.additionalItems,
                        }))));
        else if (!(p.x.minItems === undefined ||
            (p.y.minItems !== undefined && p.x.minItems <= p.y.minItems)))
            return false;
        else if (!(p.x.maxItems === undefined ||
            (p.y.maxItems !== undefined && p.x.maxItems >= p.y.maxItems)))
            return false;
        return coverStation({
            prefix: p.prefix,
            components: p.components,
            visited: p.visited,
            x: p.x.items,
            y: p.y.items,
        });
    };
    var coverObject = function (p) {
        var _a;
        if (!p.x.additionalProperties && !!p.y.additionalProperties)
            return false;
        else if (!!p.x.additionalProperties &&
            !!p.y.additionalProperties &&
            ((typeof p.x.additionalProperties === "object" &&
                p.y.additionalProperties === true) ||
                (typeof p.x.additionalProperties === "object" &&
                    typeof p.y.additionalProperties === "object" &&
                    !coverStation({
                        prefix: p.prefix,
                        components: p.components,
                        visited: p.visited,
                        x: p.x.additionalProperties,
                        y: p.y.additionalProperties,
                    }))))
            return false;
        return Object.entries((_a = p.y.properties) !== null && _a !== void 0 ? _a : {}).every(function (_a) {
            var _b, _c, _d, _e;
            var _f = __read(_a, 2), key = _f[0], b = _f[1];
            var a = (_b = p.x.properties) === null || _b === void 0 ? void 0 : _b[key];
            if (a === undefined)
                return false;
            else if (((_c = p.x.required) === null || _c === void 0 ? void 0 : _c.includes(key)) === true &&
                ((_e = (_d = p.y.required) === null || _d === void 0 ? void 0 : _d.includes(key)) !== null && _e !== void 0 ? _e : false) === false)
                return false;
            return coverStation({
                prefix: p.prefix,
                components: p.components,
                visited: p.visited,
                x: a,
                y: b,
            });
        });
    };
    var coverInteger = function (x, y) {
        if (OpenApiTypeCheckerBase.isConstant(y))
            return typeof y.const === "number" && Number.isInteger(y.const);
        return [
            x.type === y.type,
            x.minimum === undefined ||
                (y.minimum !== undefined && x.minimum <= y.minimum),
            x.maximum === undefined ||
                (y.maximum !== undefined && x.maximum >= y.maximum),
            x.exclusiveMinimum !== true ||
                x.minimum === undefined ||
                (y.minimum !== undefined &&
                    (y.exclusiveMinimum === true || x.minimum < y.minimum)),
            x.exclusiveMaximum !== true ||
                x.maximum === undefined ||
                (y.maximum !== undefined &&
                    (y.exclusiveMaximum === true || x.maximum > y.maximum)),
            x.multipleOf === undefined ||
                (y.multipleOf !== undefined &&
                    y.multipleOf / x.multipleOf ===
                        Math.floor(y.multipleOf / x.multipleOf)),
        ].every(function (v) { return v; });
    };
    var coverNumber = function (x, y) {
        if (OpenApiTypeCheckerBase.isConstant(y))
            return typeof y.const === "number";
        return [
            x.type === y.type || (x.type === "number" && y.type === "integer"),
            x.minimum === undefined ||
                (y.minimum !== undefined && x.minimum <= y.minimum),
            x.maximum === undefined ||
                (y.maximum !== undefined && x.maximum >= y.maximum),
            x.exclusiveMinimum !== true ||
                x.minimum === undefined ||
                (y.minimum !== undefined &&
                    (y.exclusiveMinimum === true || x.minimum < y.minimum)),
            x.exclusiveMaximum !== true ||
                x.maximum === undefined ||
                (y.maximum !== undefined &&
                    (y.exclusiveMaximum === true || x.maximum > y.maximum)),
            x.multipleOf === undefined ||
                (y.multipleOf !== undefined &&
                    y.multipleOf / x.multipleOf ===
                        Math.floor(y.multipleOf / x.multipleOf)),
        ].every(function (v) { return v; });
    };
    var coverString = function (x, y) {
        if (OpenApiTypeCheckerBase.isConstant(y))
            return typeof y.const === "string";
        return [
            x.format === undefined ||
                (y.format !== undefined && coverFormat(x.format, y.format)),
            x.pattern === undefined || x.pattern === y.pattern,
            x.minLength === undefined ||
                (y.minLength !== undefined && x.minLength <= y.minLength),
            x.maxLength === undefined ||
                (y.maxLength !== undefined && x.maxLength >= y.maxLength),
        ].every(function (v) { return v; });
    };
    var coverFormat = function (x, y) {
        return x === y ||
            (x === "idn-email" && y === "email") ||
            (x === "idn-hostname" && y === "hostname") ||
            (["uri", "iri"].includes(x) && y === "url") ||
            (x === "iri" && y === "uri") ||
            (x === "iri-reference" && y === "uri-reference");
    };
    var flatSchema = function (props) {
        var schema = escapeReferenceOfFlatSchema(props);
        if (OpenApiTypeCheckerBase.isOneOf(schema))
            return schema.oneOf
                .map(function (v) {
                return flatSchema({
                    prefix: props.prefix,
                    components: props.components,
                    schema: v,
                });
            })
                .flat();
        return [schema];
    };
    var escapeReferenceOfFlatSchema = function (props) {
        var _a, _b;
        if (OpenApiTypeCheckerBase.isReference(props.schema) === false)
            return props.schema;
        var key = props.schema.$ref.replace(props.prefix, "");
        var found = escapeReferenceOfFlatSchema({
            prefix: props.prefix,
            components: props.components,
            schema: (_b = (_a = props.components.schemas) === null || _a === void 0 ? void 0 : _a[key]) !== null && _b !== void 0 ? _b : {},
        });
        if (found === undefined)
            throw new Error("Reference type not found: ".concat(JSON.stringify(props.schema.$ref)));
        return escapeReferenceOfFlatSchema({
            prefix: props.prefix,
            components: props.components,
            schema: found,
        });
    };
})(OpenApiTypeCheckerBase || (exports.OpenApiTypeCheckerBase = OpenApiTypeCheckerBase = {}));
