"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChatGptTypeChecker = void 0;
var MapUtil_1 = require("./MapUtil");
var ChatGptTypeChecker;
(function (ChatGptTypeChecker) {
    /* -----------------------------------------------------------
      TYPE CHECKERS
    ----------------------------------------------------------- */
    /**
     * Test whether the schema is a nul type.
     *
     * @param schema Target schema
     * @returns Whether null type or not
     */
    ChatGptTypeChecker.isNull = function (schema) {
        return schema.type === "null";
    };
    /**
     * Test whether the schema is an unknown type.
     *
     * @param schema Target schema
     * @returns Whether unknown type or not
     */
    ChatGptTypeChecker.isUnknown = function (schema) {
        return schema.type === undefined &&
            !ChatGptTypeChecker.isAnyOf(schema) &&
            !ChatGptTypeChecker.isReference(schema);
    };
    /**
     * Test whether the schema is a boolean type.
     *
     * @param schema Target schema
     * @returns Whether boolean type or not
     */
    ChatGptTypeChecker.isBoolean = function (schema) {
        return schema.type === "boolean";
    };
    /**
     * Test whether the schema is an integer type.
     *
     * @param schema Target schema
     * @returns Whether integer type or not
     */
    ChatGptTypeChecker.isInteger = function (schema) {
        return schema.type === "integer";
    };
    /**
     * Test whether the schema is a number type.
     *
     * @param schema Target schema
     * @returns Whether number type or not
     */
    ChatGptTypeChecker.isNumber = function (schema) {
        return schema.type === "number";
    };
    /**
     * Test whether the schema is a string type.
     *
     * @param schema Target schema
     * @returns Whether string type or not
     */
    ChatGptTypeChecker.isString = function (schema) {
        return schema.type === "string";
    };
    /**
     * Test whether the schema is an array type.
     *
     * @param schema Target schema
     * @returns Whether array type or not
     */
    ChatGptTypeChecker.isArray = function (schema) {
        return schema.type === "array" &&
            schema.items !== undefined;
    };
    /**
     * Test whether the schema is an object type.
     *
     * @param schema Target schema
     * @returns Whether object type or not
     */
    ChatGptTypeChecker.isObject = function (schema) {
        return schema.type === "object";
    };
    /**
     * Test whether the schema is a reference type.
     *
     * @param schema Target schema
     * @returns Whether reference type or not
     */
    ChatGptTypeChecker.isReference = function (schema) { return schema.$ref !== undefined; };
    /**
     * Test whether the schema is an union type.
     *
     * @param schema Target schema
     * @returns Whether union type or not
     */
    ChatGptTypeChecker.isAnyOf = function (schema) {
        return schema.anyOf !== undefined;
    };
    /* -----------------------------------------------------------
      OPERATORS
    ----------------------------------------------------------- */
    /**
     * Visit every nested schemas.
     *
     * Visit every nested schemas of the target, and apply the `props.closure` function.
     *
     * Here is the list of occuring nested visitings:
     *
     * - {@link IChatGptSchema.IAnyOf.anyOf}
     * - {@link IChatGptSchema.IReference}
     * - {@link IChatGptSchema.IObject.properties}
     * - {@link IChatGptSchema.IArray.items}
     *
     * @param props Properties for visiting
     */
    ChatGptTypeChecker.visit = function (props) {
        var _a, _b;
        var already = new Set();
        var refAccessor = (_a = props.refAccessor) !== null && _a !== void 0 ? _a : "$input.$defs";
        var next = function (schema, accessor) {
            var e_1, _a;
            var _b;
            props.closure(schema, accessor);
            if (ChatGptTypeChecker.isReference(schema)) {
                var key = schema.$ref.split("#/$defs/").pop();
                if (already.has(key) === true)
                    return;
                already.add(key);
                var found = (_b = props.$defs) === null || _b === void 0 ? void 0 : _b[key];
                if (found !== undefined)
                    next(found, "".concat(refAccessor, "[").concat(key, "]"));
            }
            else if (ChatGptTypeChecker.isAnyOf(schema))
                schema.anyOf.forEach(function (s, i) { return next(s, "".concat(accessor, ".anyOf[").concat(i, "]")); });
            else if (ChatGptTypeChecker.isObject(schema))
                try {
                    for (var _c = __values(Object.entries(schema.properties)), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var _e = __read(_d.value, 2), key = _e[0], value = _e[1];
                        next(value, "".concat(accessor, ".properties[").concat(JSON.stringify(key), "]"));
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            else if (ChatGptTypeChecker.isArray(schema))
                next(schema.items, "".concat(accessor, ".items"));
        };
        next(props.schema, (_b = props.accessor) !== null && _b !== void 0 ? _b : "$input.schemas");
    };
    /**
     * Test whether the `x` schema covers the `y` schema.
     *
     * @param props Properties for testing
     * @returns Whether the `x` schema covers the `y` schema
     */
    ChatGptTypeChecker.covers = function (props) {
        return coverStation({
            $defs: props.$defs,
            x: props.x,
            y: props.y,
            visited: new Map(),
        });
    };
    var coverStation = function (p) {
        var _a;
        var cache = (_a = p.visited.get(p.x)) === null || _a === void 0 ? void 0 : _a.get(p.y);
        if (cache !== undefined)
            return cache;
        // FOR RECURSIVE CASE
        var nested = MapUtil_1.MapUtil.take(p.visited)(p.x)(function () { return new Map(); });
        nested.set(p.y, true);
        // COMPUTE IT
        var result = coverSchema(p);
        nested.set(p.y, result);
        return result;
    };
    var coverSchema = function (p) {
        // CHECK EQUALITY
        if (p.x === p.y)
            return true;
        else if (ChatGptTypeChecker.isReference(p.x) && ChatGptTypeChecker.isReference(p.y) && p.x.$ref === p.y.$ref)
            return true;
        // COMPARE WITH FLATTENING
        var alpha = flatSchema(p.$defs, p.x);
        var beta = flatSchema(p.$defs, p.y);
        if (alpha.some(function (x) { return ChatGptTypeChecker.isUnknown(x); }))
            return true;
        else if (beta.some(function (x) { return ChatGptTypeChecker.isUnknown(x); }))
            return false;
        return beta.every(function (b) {
            return alpha.some(function (a) {
                return coverEscapedSchema({
                    $defs: p.$defs,
                    visited: p.visited,
                    x: a,
                    y: b,
                });
            });
        });
    };
    var coverEscapedSchema = function (p) {
        // CHECK EQUALITY
        if (p.x === p.y)
            return true;
        else if (ChatGptTypeChecker.isUnknown(p.x))
            return true;
        else if (ChatGptTypeChecker.isUnknown(p.y))
            return false;
        else if (ChatGptTypeChecker.isNull(p.x))
            return ChatGptTypeChecker.isNull(p.y);
        // ATOMIC CASE
        else if (ChatGptTypeChecker.isBoolean(p.x))
            return ChatGptTypeChecker.isBoolean(p.y) && coverBoolean(p.x, p.y);
        else if (ChatGptTypeChecker.isInteger(p.x))
            return ChatGptTypeChecker.isInteger(p.y) && coverInteger(p.x, p.y);
        else if (ChatGptTypeChecker.isNumber(p.x))
            return ChatGptTypeChecker.isNumber(p.y) && coverNumber(p.x, p.y);
        else if (ChatGptTypeChecker.isString(p.x))
            return ChatGptTypeChecker.isString(p.y) && coverString(p.x, p.y);
        // INSTANCE CASE
        else if (ChatGptTypeChecker.isArray(p.x))
            return (ChatGptTypeChecker.isArray(p.y) &&
                coverArray({
                    $defs: p.$defs,
                    visited: p.visited,
                    x: p.x,
                    y: p.y,
                }));
        else if (ChatGptTypeChecker.isObject(p.x))
            return (ChatGptTypeChecker.isObject(p.y) &&
                coverObject({
                    $defs: p.$defs,
                    visited: p.visited,
                    x: p.x,
                    y: p.y,
                }));
        else if (ChatGptTypeChecker.isReference(p.x))
            return ChatGptTypeChecker.isReference(p.y) && p.x.$ref === p.y.$ref;
        return false;
    };
    var coverArray = function (p) {
        return coverStation({
            $defs: p.$defs,
            visited: p.visited,
            x: p.x.items,
            y: p.y.items,
        });
    };
    var coverObject = function (p) {
        var _a;
        return Object.entries((_a = p.y.properties) !== null && _a !== void 0 ? _a : {}).every(function (_a) {
            var _b, _c, _d, _e, _f;
            var _g = __read(_a, 2), key = _g[0], b = _g[1];
            var a = (_b = p.x.properties) === null || _b === void 0 ? void 0 : _b[key];
            if (a === undefined)
                return false;
            else if (((_d = (_c = p.x.required) === null || _c === void 0 ? void 0 : _c.includes(key)) !== null && _d !== void 0 ? _d : false) === true &&
                ((_f = (_e = p.y.required) === null || _e === void 0 ? void 0 : _e.includes(key)) !== null && _f !== void 0 ? _f : false) === false)
                return false;
            return coverStation({
                $defs: p.$defs,
                visited: p.visited,
                x: a,
                y: b,
            });
        });
    };
    var coverBoolean = function (x, y) {
        var _a, _b;
        if (!!((_a = x.enum) === null || _a === void 0 ? void 0 : _a.length))
            return !!((_b = y.enum) === null || _b === void 0 ? void 0 : _b.length) && y.enum.every(function (v) { return x.enum.includes(v); });
        return true;
    };
    var coverInteger = function (x, y) {
        var _a, _b;
        if (!!((_a = x.enum) === null || _a === void 0 ? void 0 : _a.length))
            return !!((_b = y.enum) === null || _b === void 0 ? void 0 : _b.length) && y.enum.every(function (v) { return x.enum.includes(v); });
        return x.type === y.type;
    };
    var coverNumber = function (x, y) {
        var _a, _b;
        if (!!((_a = x.enum) === null || _a === void 0 ? void 0 : _a.length))
            return !!((_b = y.enum) === null || _b === void 0 ? void 0 : _b.length) && y.enum.every(function (v) { return x.enum.includes(v); });
        return x.type === y.type || (x.type === "number" && y.type === "integer");
    };
    var coverString = function (x, y) {
        var _a, _b;
        if (!!((_a = x.enum) === null || _a === void 0 ? void 0 : _a.length))
            return !!((_b = y.enum) === null || _b === void 0 ? void 0 : _b.length) && y.enum.every(function (v) { return x.enum.includes(v); });
        return x.type === y.type;
    };
    var flatSchema = function ($defs, schema) {
        schema = escapeReference($defs, schema);
        if (ChatGptTypeChecker.isAnyOf(schema))
            return schema.anyOf.map(function (v) { return flatSchema($defs, v); }).flat();
        return [schema];
    };
    var escapeReference = function ($defs, schema) {
        return ChatGptTypeChecker.isReference(schema)
            ? escapeReference($defs, $defs[schema.$ref.replace("#/$defs/", "")])
            : schema;
    };
})(ChatGptTypeChecker || (exports.ChatGptTypeChecker = ChatGptTypeChecker = {}));
