{"version":3,"file":"ChatGptTypeChecker.mjs","sources":["../../src/utils/ChatGptTypeChecker.ts"],"sourcesContent":["import { IChatGptSchema } from \"../structures/IChatGptSchema\";\nimport { MapUtil } from \"./MapUtil\";\n\nexport namespace ChatGptTypeChecker {\n  /* -----------------------------------------------------------\n    TYPE CHECKERS\n  ----------------------------------------------------------- */\n  /**\n   * Test whether the schema is a nul type.\n   *\n   * @param schema Target schema\n   * @returns Whether null type or not\n   */\n  export const isNull = (\n    schema: IChatGptSchema,\n  ): schema is IChatGptSchema.INull =>\n    (schema as IChatGptSchema.INull).type === \"null\";\n\n  /**\n   * Test whether the schema is an unknown type.\n   *\n   * @param schema Target schema\n   * @returns Whether unknown type or not\n   */\n  export const isUnknown = (\n    schema: IChatGptSchema,\n  ): schema is IChatGptSchema.IUnknown =>\n    (schema as IChatGptSchema.IUnknown).type === undefined &&\n    !isAnyOf(schema) &&\n    !isReference(schema);\n\n  /**\n   * Test whether the schema is a boolean type.\n   *\n   * @param schema Target schema\n   * @returns Whether boolean type or not\n   */\n  export const isBoolean = (\n    schema: IChatGptSchema,\n  ): schema is IChatGptSchema.IBoolean =>\n    (schema as IChatGptSchema.IBoolean).type === \"boolean\";\n\n  /**\n   * Test whether the schema is an integer type.\n   *\n   * @param schema Target schema\n   * @returns Whether integer type or not\n   */\n  export const isInteger = (\n    schema: IChatGptSchema,\n  ): schema is IChatGptSchema.IInteger =>\n    (schema as IChatGptSchema.IInteger).type === \"integer\";\n\n  /**\n   * Test whether the schema is a number type.\n   *\n   * @param schema Target schema\n   * @returns Whether number type or not\n   */\n  export const isNumber = (\n    schema: IChatGptSchema,\n  ): schema is IChatGptSchema.INumber =>\n    (schema as IChatGptSchema.INumber).type === \"number\";\n\n  /**\n   * Test whether the schema is a string type.\n   *\n   * @param schema Target schema\n   * @returns Whether string type or not\n   */\n  export const isString = (\n    schema: IChatGptSchema,\n  ): schema is IChatGptSchema.IString =>\n    (schema as IChatGptSchema.IString).type === \"string\";\n\n  /**\n   * Test whether the schema is an array type.\n   *\n   * @param schema Target schema\n   * @returns Whether array type or not\n   */\n  export const isArray = (\n    schema: IChatGptSchema,\n  ): schema is IChatGptSchema.IArray =>\n    (schema as IChatGptSchema.IArray).type === \"array\" &&\n    (schema as IChatGptSchema.IArray).items !== undefined;\n\n  /**\n   * Test whether the schema is an object type.\n   *\n   * @param schema Target schema\n   * @returns Whether object type or not\n   */\n  export const isObject = (\n    schema: IChatGptSchema,\n  ): schema is IChatGptSchema.IObject =>\n    (schema as IChatGptSchema.IObject).type === \"object\";\n\n  /**\n   * Test whether the schema is a reference type.\n   *\n   * @param schema Target schema\n   * @returns Whether reference type or not\n   */\n  export const isReference = (\n    schema: IChatGptSchema,\n  ): schema is IChatGptSchema.IReference => (schema as any).$ref !== undefined;\n\n  /**\n   * Test whether the schema is an union type.\n   *\n   * @param schema Target schema\n   * @returns Whether union type or not\n   */\n  export const isAnyOf = (\n    schema: IChatGptSchema,\n  ): schema is IChatGptSchema.IAnyOf =>\n    (schema as IChatGptSchema.IAnyOf).anyOf !== undefined;\n\n  /* -----------------------------------------------------------\n    OPERATORS\n  ----------------------------------------------------------- */\n  /**\n   * Visit every nested schemas.\n   *\n   * Visit every nested schemas of the target, and apply the `props.closure` function.\n   *\n   * Here is the list of occuring nested visitings:\n   *\n   * - {@link IChatGptSchema.IAnyOf.anyOf}\n   * - {@link IChatGptSchema.IReference}\n   * - {@link IChatGptSchema.IObject.properties}\n   * - {@link IChatGptSchema.IArray.items}\n   *\n   * @param props Properties for visiting\n   */\n  export const visit = (props: {\n    closure: (schema: IChatGptSchema, accessor: string) => void;\n    $defs?: Record<string, IChatGptSchema> | undefined;\n    schema: IChatGptSchema;\n    accessor?: string;\n    refAccessor?: string;\n  }): void => {\n    const already: Set<string> = new Set();\n    const refAccessor: string = props.refAccessor ?? \"$input.$defs\";\n    const next = (schema: IChatGptSchema, accessor: string): void => {\n      props.closure(schema, accessor);\n      if (ChatGptTypeChecker.isReference(schema)) {\n        const key: string = schema.$ref.split(\"#/$defs/\").pop()!;\n        if (already.has(key) === true) return;\n        already.add(key);\n        const found: IChatGptSchema | undefined = props.$defs?.[key];\n        if (found !== undefined) next(found, `${refAccessor}[${key}]`);\n      } else if (ChatGptTypeChecker.isAnyOf(schema))\n        schema.anyOf.forEach((s, i) => next(s, `${accessor}.anyOf[${i}]`));\n      else if (ChatGptTypeChecker.isObject(schema))\n        for (const [key, value] of Object.entries(schema.properties))\n          next(value, `${accessor}.properties[${JSON.stringify(key)}]`);\n      else if (ChatGptTypeChecker.isArray(schema))\n        next(schema.items, `${accessor}.items`);\n    };\n    next(props.schema, props.accessor ?? \"$input.schemas\");\n  };\n\n  /**\n   * Test whether the `x` schema covers the `y` schema.\n   *\n   * @param props Properties for testing\n   * @returns Whether the `x` schema covers the `y` schema\n   */\n  export const covers = (props: {\n    $defs?: Record<string, IChatGptSchema> | undefined;\n    x: IChatGptSchema;\n    y: IChatGptSchema;\n  }): boolean =>\n    coverStation({\n      $defs: props.$defs,\n      x: props.x,\n      y: props.y,\n      visited: new Map(),\n    });\n\n  const coverStation = (p: {\n    $defs?: Record<string, IChatGptSchema> | undefined;\n    visited: Map<IChatGptSchema, Map<IChatGptSchema, boolean>>;\n    x: IChatGptSchema;\n    y: IChatGptSchema;\n  }): boolean => {\n    const cache: boolean | undefined = p.visited.get(p.x)?.get(p.y);\n    if (cache !== undefined) return cache;\n\n    // FOR RECURSIVE CASE\n    const nested: Map<IChatGptSchema, boolean> = MapUtil.take(p.visited)(p.x)(\n      () => new Map(),\n    );\n    nested.set(p.y, true);\n\n    // COMPUTE IT\n    const result: boolean = coverSchema(p);\n    nested.set(p.y, result);\n    return result;\n  };\n\n  const coverSchema = (p: {\n    $defs?: Record<string, IChatGptSchema> | undefined;\n    visited: Map<IChatGptSchema, Map<IChatGptSchema, boolean>>;\n    x: IChatGptSchema;\n    y: IChatGptSchema;\n  }): boolean => {\n    // CHECK EQUALITY\n    if (p.x === p.y) return true;\n    else if (isReference(p.x) && isReference(p.y) && p.x.$ref === p.y.$ref)\n      return true;\n\n    // COMPARE WITH FLATTENING\n    const alpha: IChatGptSchema[] = flatSchema(p.$defs, p.x);\n    const beta: IChatGptSchema[] = flatSchema(p.$defs, p.y);\n    if (alpha.some((x) => isUnknown(x))) return true;\n    else if (beta.some((x) => isUnknown(x))) return false;\n    return beta.every((b) =>\n      alpha.some((a) =>\n        coverEscapedSchema({\n          $defs: p.$defs,\n          visited: p.visited,\n          x: a,\n          y: b,\n        }),\n      ),\n    );\n  };\n\n  const coverEscapedSchema = (p: {\n    $defs?: Record<string, IChatGptSchema> | undefined;\n    visited: Map<IChatGptSchema, Map<IChatGptSchema, boolean>>;\n    x: IChatGptSchema;\n    y: IChatGptSchema;\n  }): boolean => {\n    // CHECK EQUALITY\n    if (p.x === p.y) return true;\n    else if (isUnknown(p.x)) return true;\n    else if (isUnknown(p.y)) return false;\n    else if (isNull(p.x)) return isNull(p.y);\n    // ATOMIC CASE\n    else if (isBoolean(p.x)) return isBoolean(p.y) && coverBoolean(p.x, p.y);\n    else if (isInteger(p.x)) return isInteger(p.y) && coverInteger(p.x, p.y);\n    else if (isNumber(p.x)) return isNumber(p.y) && coverNumber(p.x, p.y);\n    else if (isString(p.x)) return isString(p.y) && coverString(p.x, p.y);\n    // INSTANCE CASE\n    else if (isArray(p.x))\n      return (\n        isArray(p.y) &&\n        coverArray({\n          $defs: p.$defs,\n          visited: p.visited,\n          x: p.x,\n          y: p.y,\n        })\n      );\n    else if (isObject(p.x))\n      return (\n        isObject(p.y) &&\n        coverObject({\n          $defs: p.$defs,\n          visited: p.visited,\n          x: p.x,\n          y: p.y,\n        })\n      );\n    else if (isReference(p.x)) return isReference(p.y) && p.x.$ref === p.y.$ref;\n    return false;\n  };\n\n  const coverArray = (p: {\n    $defs?: Record<string, IChatGptSchema> | undefined;\n    visited: Map<IChatGptSchema, Map<IChatGptSchema, boolean>>;\n    x: IChatGptSchema.IArray;\n    y: IChatGptSchema.IArray;\n  }): boolean =>\n    coverStation({\n      $defs: p.$defs,\n      visited: p.visited,\n      x: p.x.items,\n      y: p.y.items,\n    });\n\n  const coverObject = (p: {\n    $defs?: Record<string, IChatGptSchema> | undefined;\n    visited: Map<IChatGptSchema, Map<IChatGptSchema, boolean>>;\n    x: IChatGptSchema.IObject;\n    y: IChatGptSchema.IObject;\n  }): boolean =>\n    Object.entries(p.y.properties ?? {}).every(([key, b]) => {\n      const a: IChatGptSchema | undefined = p.x.properties?.[key];\n      if (a === undefined) return false;\n      else if (\n        (p.x.required?.includes(key) ?? false) === true &&\n        (p.y.required?.includes(key) ?? false) === false\n      )\n        return false;\n      return coverStation({\n        $defs: p.$defs,\n        visited: p.visited,\n        x: a,\n        y: b,\n      });\n    });\n\n  const coverBoolean = (\n    x: IChatGptSchema.IBoolean,\n    y: IChatGptSchema.IBoolean,\n  ): boolean => {\n    if (!!x.enum?.length)\n      return !!y.enum?.length && y.enum.every((v) => x.enum!.includes(v));\n    return true;\n  };\n\n  const coverInteger = (\n    x: IChatGptSchema.IInteger,\n    y: IChatGptSchema.IInteger,\n  ): boolean => {\n    if (!!x.enum?.length)\n      return !!y.enum?.length && y.enum.every((v) => x.enum!.includes(v));\n    return x.type === y.type;\n  };\n\n  const coverNumber = (\n    x: IChatGptSchema.INumber,\n    y: IChatGptSchema.IInteger | IChatGptSchema.INumber,\n  ): boolean => {\n    if (!!x.enum?.length)\n      return !!y.enum?.length && y.enum.every((v) => x.enum!.includes(v));\n    return x.type === y.type || (x.type === \"number\" && y.type === \"integer\");\n  };\n\n  const coverString = (\n    x: IChatGptSchema.IString,\n    y: IChatGptSchema.IString,\n  ): boolean => {\n    if (!!x.enum?.length)\n      return !!y.enum?.length && y.enum.every((v) => x.enum!.includes(v));\n    return x.type === y.type;\n  };\n\n  const flatSchema = (\n    $defs: Record<string, IChatGptSchema> | undefined,\n    schema: IChatGptSchema,\n  ): IChatGptSchema[] => {\n    schema = escapeReference($defs, schema);\n    if (isAnyOf(schema))\n      return schema.anyOf.map((v) => flatSchema($defs, v)).flat();\n    return [schema];\n  };\n\n  const escapeReference = (\n    $defs: Record<string, IChatGptSchema> | undefined,\n    schema: IChatGptSchema,\n  ): Exclude<IChatGptSchema, IChatGptSchema.IReference> =>\n    isReference(schema)\n      ? escapeReference($defs, $defs![schema.$ref.replace(\"#/$defs/\", \"\")]!)\n      : schema;\n}\n"],"names":["ChatGptTypeChecker","isNull","schema","type","isUnknown","undefined","isAnyOf","isReference","isBoolean","isInteger","isNumber","isString","isArray","items","isObject","$ref","anyOf","visit","props","already","Set","refAccessor","next","accessor","closure","key","split","pop","has","add","found","$defs","forEach","s","i","value","Object","entries","properties","JSON","stringify","covers","coverStation","x","y","visited","Map","p","cache","get","nested","MapUtil","take","set","result","coverSchema","alpha","flatSchema","beta","some","every","b","a","coverEscapedSchema","coverBoolean","coverInteger","coverNumber","coverString","coverArray","coverObject","required","includes","enum","length","v","escapeReference","map","flat","replace"],"mappings":"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"}